#!/bin/bash
# An interactive TUI for managing and connecting to SSH hosts.

# The return value of a pipeline is the status of the last command to exit with a non-zero status.
set -o pipefail

# --- Shared Utilities ---

# --- Colors and Styles ---
export C_RED='\e[31m'
export C_GREEN='\e[32m'
export C_YELLOW='\e[33m'
export C_BLUE='\e[34m'
export C_MAGENTA='\e[35m'
export C_CYAN='\e[36m'
export C_WHITE='\e[37m'
export C_GRAY='\e[38;5;244m'
export C_L_RED='\e[31;1m'
export C_L_GREEN='\e[32;1m'
export C_L_YELLOW='\e[33;1m'
export C_L_BLUE='\e[34;1m'
export C_L_MAGENTA='\e[35;1m'
export C_L_CYAN='\e[36;1m'
export C_L_WHITE='\e[37;1m'
export C_L_GRAY='\e[38;5;252m'

# Background Colors
export BG_BLACK='\e[40;1m'
export BG_RED='\e[41;1m'
export BG_GREEN='\e[42;1m'
export BG_YELLOW='\e[43;1m'
export BG_BLUE='\e[44;1m'

# Text Colors
export C_BLACK='\e[30;1m'

export T_RESET='\e[0m'
export T_BOLD='\e[1m'
export T_ULINE='\e[4m'
export T_REVERSE='\e[7m'
export T_CLEAR_LINE='\e[K'
export T_CURSOR_HIDE='\e[?25l'
export T_CURSOR_SHOW='\e[?25h'

export T_ERR="${T_BOLD}\e[31;1m"
export T_ERR_ICON="[${T_BOLD}${C_RED}✗${T_RESET}]"

export T_OK_ICON="[${T_BOLD}${C_GREEN}✓${T_RESET}]"
export T_INFO_ICON="[${T_BOLD}${C_YELLOW}i${T_RESET}]"
export T_WARN_ICON="[${T_BOLD}${C_YELLOW}!${T_RESET}]"
export T_QST_ICON="[${T_BOLD}${C_L_CYAN}?${T_RESET}]"

export DIV="──────────────────────────────────────────────────────────────────────"

# --- Key Codes ---
export KEY_ESC=$'\e'
export KEY_UP=$'\e[A'
export KEY_DOWN=$'\e[B'
export KEY_RIGHT=$'\e[C'
export KEY_LEFT=$'\e[D'
export KEY_ENTER="ENTER"
export KEY_TAB=$'\t'
export KEY_BACKSPACE=$'\x7f' # ASCII DEL character for backspace
export KEY_HOME=$'\e[H'
export KEY_END=$'\e[F'
export KEY_DELETE=$'\e[3~'

# --- Utility Functions ---

# --- Logging & Banners ---
printMsg() {
  echo -e "${1}"
}

printMsgNoNewline() {
  echo -n -e "${1}"
}

printErrMsg() {
  printMsg "${T_ERR_ICON}${T_ERR} ${1} ${T_RESET}"
}

printOkMsg() {
  printMsg "${T_OK_ICON} ${1}${T_RESET}"
}

printInfoMsg() {
  printMsg "${T_INFO_ICON} ${1}${T_RESET}"
}

printWarnMsg() {
  printMsg "${T_WARN_ICON} ${1}${T_RESET}"
}

# Generates a banner string.
generate_banner_string() {
    local prompt="$1"
    # H1-style banner for top-level calls
    echo -n -e "${C_L_BLUE}+ ${prompt}\n${DIV}${T_RESET}"
}

printBanner() {
  # Prints a banner generated by the shared banner logic.
  printMsg "$(generate_banner_string "$1")"
}

# --- Terminal Control ---
clear_current_line() {
    # \e[2K: clear entire line
    # \r: move cursor to beginning of the line
    echo -ne "\e[2K\r" >/dev/tty
}

clear_lines_up() {
    local lines=${1:-1} # Default to 1 line if no argument is provided
    for ((i = 0; i < lines; i++)); do
        # \e[1A: move cursor up one line
        # \e[2K: clear entire line
        echo -ne "\e[1A\e[2K"
    done
    echo -ne "\r" # Move cursor to the beginning of the line
} >/dev/tty

clear_lines_down() {
    local lines=${1:-1}
    if (( lines <= 0 )); then return; fi

    for ((i = 0; i < lines; i++)); do
        # \e[2K: clear entire line
        # \n: move to next line
        echo -ne "\e[2K\n"
    done
    # \e[<N>A: move cursor up N lines
    echo -ne "\e[${lines}A"
} >/dev/tty

move_cursor_up() {
    local lines=${1:-1}
    # Redirect all output of this function to /dev/tty to ensure it works
    # even when the script's stdout is being captured (e.g., in command substitution).
    if (( lines > 0 )); then
        # Using a loop of "up 1" can be more reliable in some terminals
        # than a single "up N" command, which helps prevent screen tearing.
        for ((i = 0; i < lines; i++)); do echo -ne "\e[1A"; done
    fi
    echo -ne "\r" # Move cursor to the beginning of the line
} >/dev/tty

# --- User Input ---
read_single_char() {
    local char
    local seq
    # -s: silent, -n 1: one char, -r: raw
    IFS= read -rsn1 char
    # Check for Enter key, which read consumes but returns as an empty string.
    if [[ -z "$char" ]]; then
        echo "$KEY_ENTER"
        return
    fi
    # If the character is ESC, check for a following sequence.
    if [[ "$char" == "$KEY_ESC" ]]; then
        # Try to read the rest of an escape sequence with a short timeout.
        # This loop will continue to read as long as characters are
        # available in the input buffer without a significant delay.
        # This is more robust than reading a fixed number of characters.
        while IFS= read -rsn1 -t 0.001 seq; do
            char+="$seq"
        done
    fi
    echo "$char"
}

prompt_yes_no() {
    local question="$1"
    local default_answer="${2:-}" # Optional second argument
    local prompt_suffix
    local answer

    # Determine the prompt suffix based on the default
    if [[ "$default_answer" == "y" ]]; then
        prompt_suffix="(Y/n)"
    elif [[ "$default_answer" == "n" ]]; then
        prompt_suffix="(y/N)"
    else
        prompt_suffix="(y/n)"
    fi

    while true; do
        printMsgNoNewline "${T_QST_ICON} ${question} ${prompt_suffix} "
        answer=$(read_single_char)
        
        # If the answer is the ENTER key, use the default.
        if [[ "$answer" == "$KEY_ENTER" ]]; then
            answer="$default_answer"
        fi

        case "$answer" in
            [Yy])
                clear_current_line
                return 0 # Success (Yes)
                ;;
            [Nn])
                clear_current_line
                return 1 # Failure (No)
                ;;
            "$KEY_ESC"|"q")
                clear_current_line
                printMsg "${T_QST_ICON} ${question} ${prompt_suffix}\n ${C_L_YELLOW}-- cancelled --${T_RESET}"
                return 2 # Cancelled
                ;;
            *)
                clear_current_line
                printErrMsg "Invalid input. Please enter 'y' or 'n'."
                # Loop will continue.
                ;;
        esac
    done
}

prompt_to_continue() {
    printInfoMsg "Press any key to continue..." >/dev/tty
    # -s: silent, -n 1: read 1 char, -r: raw
    # We redirect to /dev/tty to ensure it works even if stdout is captured.
    read -rsn1 </dev/tty
    # Clear the "Press any key..." message.
    clear_lines_up 1
}

# --- Interactive Menus ---
interactive_multi_select_menu() {
    # Ensure the script is running in an interactive terminal
    if ! [[ -t 0 ]]; then printErrMsg "Not an interactive session." >&2; return 1; fi
    local prompt="$1"; local header="$2"; shift 2; local -a options=("$@"); local num_options=${#options[@]}
    if [[ $num_options -eq 0 ]]; then printErrMsg "No options provided to menu." >&2; return 1; fi
    local current_option=0; local -a selected_options=(); for ((i=0; i<num_options; i++)); do selected_options[i]=0; done
    local header_lines=0
    if [[ -n "$header" ]]; then
        header_lines=$(echo -e "$header" | wc -l)
    fi
    _draw_menu_options() {
        local output=""; for i in "${!options[@]}"; do
            local pointer=" "; local checkbox="[ ]"; local highlight_start=""; local highlight_end=""
            if (( selected_options[i] == 1 )); then checkbox="${C_GREEN}${T_BOLD}[✓]${T_RESET}"; fi
            if (( i == current_option )); then pointer="${T_BOLD}${C_L_MAGENTA}❯${T_RESET}"; highlight_start="${T_REVERSE}"; highlight_end="${T_RESET}"; fi
            output+=" ${pointer} ${highlight_start}${checkbox} ${options[i]}${highlight_end}${T_RESET}${T_CLEAR_LINE}\n"; done
        echo -ne "$output"; }
    printMsgNoNewline "${T_CURSOR_HIDE}" >/dev/tty; trap 'printMsgNoNewline "${T_CURSOR_SHOW}" >/dev/tty' EXIT
    echo -e "${T_QST_ICON} ${prompt}" >/dev/tty; echo -e "${C_GRAY}${DIV}${T_RESET}" >/dev/tty
    if [[ -n "$header" ]]; then
        echo -e "  ${header}${T_RESET}" >/dev/tty
    fi
    _draw_menu_options >/dev/tty
    echo -e "${C_GRAY}${DIV}${T_RESET}" >/dev/tty
    echo -e "  ${C_L_CYAN}↓/↑${C_WHITE} Move | ${C_L_CYAN}SPACE${C_WHITE} to select | ${C_L_GREEN}ENTER${C_WHITE} to confirm | ${C_L_YELLOW}Q/ESC${C_GRAY} to cancel${T_RESET}" >/dev/tty

    move_cursor_up 2 # Move to end of options list

    local key; local lines_above=$((2 + header_lines)); local lines_below=2; while true; do
        move_cursor_up "$num_options"; key=$(read_single_char </dev/tty)
        case "$key" in
            "$KEY_UP"|"k") current_option=$(( (current_option - 1 + num_options) % num_options ));;
            "$KEY_DOWN"|"j") current_option=$(( (current_option + 1) % num_options ));;
            ' '|"h"|"l") selected_options[current_option]=$(( 1 - selected_options[current_option] ))
                if [[ "${options[0]}" == "All" ]]; then
                    if (( current_option == 0 )); then local all_state=${selected_options[0]}; for i in "${!options[@]}"; do selected_options[i]=$all_state; done
                    else local all_selected=1; for ((i=1; i<num_options; i++)); do if (( selected_options[i] == 0 )); then all_selected=0; break; fi; done; selected_options[0]=$all_selected; fi
                fi;;
            "$KEY_ENTER"|"$KEY_ESC"|"q")
                clear_lines_down $((num_options + lines_below)); clear_lines_up "$lines_above"
                if [[ "$key" == "$KEY_ENTER" ]]; then
                    break
                else
                    return 1
                fi;;
        esac; _draw_menu_options >/dev/tty; done
    local has_selection=0; for i in "${!options[@]}"; do if [[ ${selected_options[i]} -eq 1 ]]; then has_selection=1; echo "$i"; fi; done
    if [[ $has_selection -eq 1 ]]; then return 0; else return 1; fi
}

interactive_single_select_menu() {
    if ! [[ -t 0 ]]; then printErrMsg "Not an interactive session." >&2; return 1; fi
    local prompt="$1"; local header="$2"; shift 2; local -a options=("$@"); local num_options=${#options[@]}
    if [[ $num_options -eq 0 ]]; then printErrMsg "No options provided to menu." >&2; return 1; fi
    local current_option=0
    local header_lines=0
    if [[ -n "$header" ]]; then
        # Count newlines in header to correctly calculate menu height for clearing.
        header_lines=$(echo -e "$header" | wc -l)
    fi

    _draw_menu_options() {
        local output=""; for i in "${!options[@]}"; do
            local pointer=" "; local highlight_start=""; local highlight_end=""
            if (( i == current_option )); then pointer="${T_BOLD}${C_L_MAGENTA}❯${T_RESET}"; highlight_start="${T_REVERSE}${C_L_CYAN}"; highlight_end="${T_RESET}"; fi
            output+=" ${pointer} ${highlight_start} ${options[i]} ${highlight_end}${T_RESET}${T_CLEAR_LINE}\n"; done
        echo -ne "$output"; }
    printMsgNoNewline "${T_CURSOR_HIDE}" >/dev/tty; trap 'printMsgNoNewline "${T_CURSOR_SHOW}" >/dev/tty' EXIT
    echo -e "${T_QST_ICON} ${prompt}" >/dev/tty; echo -e "${C_GRAY}${DIV}${T_RESET}" >/dev/tty
    if [[ -n "$header" ]]; then
        echo -e "  ${header}${T_RESET}" >/dev/tty
    fi
    _draw_menu_options >/dev/tty
    echo -e "${C_GRAY}${DIV}${T_RESET}" >/dev/tty
    #echo -e "${C_GRAY}(Use ${C_L_CYAN}↓/↑${C_GRAY} to navigate, ${C_L_GREEN}enter${C_GRAY} to confirm, ${C_L_YELLOW}q/esc${C_GRAY} to cancel)${T_RESET}" >/dev/tty
    echo -e "  ${C_L_CYAN}↓/↑/j/k${C_WHITE} Move | ${C_L_GREEN}ENTER${C_WHITE} to confirm, ${C_L_YELLOW}Q/ESC${C_GRAY} to cancel${T_RESET}" >/dev/tty

    move_cursor_up 2 # Move to end of options list

    local key; local lines_above=$((2 + header_lines)); local lines_below=2; while true; do
        move_cursor_up "$num_options"; key=$(read_single_char </dev/tty)
        case "$key" in
            "$KEY_UP"|"k") current_option=$(( (current_option - 1 + num_options) % num_options ));;
            "$KEY_DOWN"|"j") current_option=$(( (current_option + 1) % num_options ));;
            "$KEY_ENTER") clear_lines_down $((num_options + lines_below)); clear_lines_up "$lines_above"; echo "$current_option"; return 0;;
            "$KEY_ESC"|"q") clear_lines_down $((num_options + lines_below)); clear_lines_up "$lines_above"; return 1;;
        esac; _draw_menu_options >/dev/tty; done
}

interactive_reorder_menu() {
    if ! [[ -t 0 ]]; then printErrMsg "Not an interactive session." >&2; return 1; fi
    local prompt="$1"; shift; local -a current_items=("$@"); local num_items=${#current_items[@]}
    if [[ $num_items -eq 0 ]]; then printErrMsg "No items provided to reorder menu." >&2; return 1; fi
    local current_pos=0; local held_item_idx=-1
    _draw_reorder_menu() {
        local output=""; for i in "${!current_items[@]}"; do
            local pointer=" "; local highlight_start=""; local highlight_end=""
            if (( i == current_pos )); then pointer="${T_BOLD}${C_L_MAGENTA}❯${T_RESET}"; fi
            if (( i == held_item_idx )); then highlight_start="${T_REVERSE}"; highlight_end="${T_RESET}"; fi
            output+="  ${pointer} ${highlight_start}${current_items[i]}${highlight_end}${T_RESET}${T_CLEAR_LINE}\n"; done
        echo -ne "$output"; }
    printMsgNoNewline "${T_CURSOR_HIDE}" >/dev/tty; trap 'printMsgNoNewline "${T_CURSOR_SHOW}" >/dev/tty' EXIT
    echo -e "${T_QST_ICON} ${prompt}" >/dev/tty; echo -e "${C_GRAY}${DIV}${T_RESET}" >/dev/tty
    _draw_reorder_menu >/dev/tty
    echo -e "${C_GRAY}${DIV}${T_RESET}" >/dev/tty
    echo -e "${C_GRAY}(${C_L_CYAN}↓/↑/j/k${C_GRAY} move, ${C_L_CYAN}space${C_GRAY} grab/drop, ${C_L_GREEN}enter${C_GRAY} save, ${C_L_YELLOW}q/esc${C_GRAY} cancel)${T_RESET}" >/dev/tty

    move_cursor_up 2 # Move to end of items list

    local key; local lines_above=2; local lines_below=2; while true; do
        move_cursor_up "$num_items"; key=$(read_single_char </dev/tty)
        case "$key" in
            "$KEY_UP"|"k")
                if (( held_item_idx != -1 )); then
                    if (( held_item_idx > 0 )); then local next_idx=$((held_item_idx - 1)); local tmp="${current_items[held_item_idx]}"; current_items[held_item_idx]="${current_items[next_idx]}"; current_items[next_idx]="$tmp"; held_item_idx=$next_idx; current_pos=$next_idx; fi
                else current_pos=$(( (current_pos - 1 + num_items) % num_items )); fi;;
            "$KEY_DOWN"|"j")
                if (( held_item_idx != -1 )); then
                    if (( held_item_idx < num_items - 1 )); then local next_idx=$((held_item_idx + 1)); local tmp="${current_items[held_item_idx]}"; current_items[held_item_idx]="${current_items[next_idx]}"; current_items[next_idx]="$tmp"; held_item_idx=$next_idx; current_pos=$next_idx; fi
                else current_pos=$(( (current_pos + 1) % num_items )); fi;;
            ' ') (( held_item_idx == current_pos )) && held_item_idx=-1 || held_item_idx=$current_pos ;;
            "$KEY_ENTER") clear_lines_down $((num_items + lines_below)); clear_lines_up "$lines_above"; printf "%s\n" "${current_items[@]}"; return 0;;
            "$KEY_ESC"|"q") clear_lines_down $((num_items + lines_below)); clear_lines_up "$lines_above"; return 1;;
        esac; _draw_reorder_menu >/dev/tty; done
}

# (Private) A generic, reusable interactive list view.
# This function abstracts the common pattern of displaying a list of items,
# handling navigation, and dispatching actions.
#
# Usage: _interactive_list_view <banner> <header_func> <refresh_func> <key_handler_func> <footer_func>
#   - banner: The title string to display at the top.
#   - header_func: The name of a function that prints the list's column headers.
#   - refresh_func: The name of a function that populates the data arrays. It must accept two
#                   nameref arguments: the first for the display strings, the second for raw data payloads.
#   - key_handler_func: The name of a function to handle key presses. It receives the key, the selected
#                       data payload, and the selected index. It must return:
#                       0 = no-op, 1 = refresh list, 2 = exit view.
#   - footer_func: The name of a function that prints the help text at the bottom.
_interactive_list_view() {
    local banner="$1"
    local header_func="$2"
    local refresh_func="$3"
    local key_handler_func="$4"
    local footer_func="$5"

    printMsgNoNewline "${T_CURSOR_HIDE}" >/dev/tty
    trap 'printMsgNoNewline "${T_CURSOR_SHOW}" >/dev/tty' RETURN

    local current_option=0
    local -a menu_options=()
    local -a data_payloads=()
    local num_options=0

    # (Private) Fetches data and clamps the selection index.
    _refresh_data() {
        "$refresh_func" menu_options data_payloads
        num_options=${#menu_options[@]}
        if (( current_option >= num_options )); then current_option=$(( num_options - 1 )); fi
        if (( current_option < 0 )); then current_option=0; fi
    }

    # (Private) Draws the entire UI.
    _draw_view() {
        clear
        printBanner "$banner"
        "$header_func"
        printMsg "${C_GRAY}${DIV}${T_RESET}"

        if [[ $num_options -gt 0 ]]; then
            for i in "${!menu_options[@]}"; do
                local pointer=" "; local highlight_start=""; local highlight_end=""
                if (( i == current_option )); then
                    pointer="${T_BOLD}${C_L_MAGENTA}❯${T_RESET}"
                    highlight_start="${T_REVERSE}"
                    highlight_end="${T_RESET}"
                fi
                printMsg " ${pointer} ${highlight_start}${menu_options[i]}${highlight_end}"
            done
        else
            printMsg "  ${C_GRAY}(No items found.)${T_RESET}"
        fi

        printMsg "${C_GRAY}${DIV}${T_RESET}"
        "$footer_func"
        printMsg "${C_GRAY}${DIV}${T_RESET}"
    }

    _refresh_data # Initial data load
    while true; do
        _draw_view
        local key; key=$(read_single_char)
        local selected_payload=""; if (( num_options > 0 )); then selected_payload="${data_payloads[$current_option]}"; fi
        case "$key" in
            "$KEY_UP"|"k") if (( num_options > 0 )); then current_option=$(( (current_option - 1 + num_options) % num_options )); fi;;
            "$KEY_DOWN"|"j") if (( num_options > 0 )); then current_option=$(( (current_option + 1) % num_options )); fi;;
            *) local handler_result; "$key_handler_func" "$key" "$selected_payload" "$current_option" handler_result
               if [[ "$handler_result" -eq 1 ]]; then _refresh_data; elif [[ "$handler_result" -eq 2 ]]; then break; fi;;
        esac
    done
}

# --- Error Handling & Traps ---
script_interrupt_handler() {
    trap - INT; clear; printMsg "${T_WARN_ICON} ${C_L_YELLOW}Operation cancelled by user.${T_RESET}"; exit 130; }
trap 'script_interrupt_handler' INT

# --- Prerequisite & Sanity Checks ---
_check_command_exists() { command -v "$1" &>/dev/null; }
prereq_checks() {
    local missing_commands=(); printMsgNoNewline "${T_INFO_ICON} Running prereq checks"
    for cmd in "$@"; do printMsgNoNewline "${C_L_BLUE}.${T_RESET}"; if ! _check_command_exists "$cmd"; then missing_commands+=("$cmd"); fi; done; echo
    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        clear_lines_up 1; printErrMsg "Prerequisite checks failed. Missing commands:"
        for cmd in "${missing_commands[@]}"; do printMsg "    - ${C_L_YELLOW}${cmd}${T_RESET}"; done
        printMsg "${T_INFO_ICON} Please install the missing commands and try again."; exit 1
    fi; clear_lines_up 1
}

# --- Spinners ---
SPINNER_OUTPUT=""
_run_with_spinner_non_interactive() {
    local desc="$1"; shift; local cmd=("$@"); printMsgNoNewline "${desc} " >&2
    if SPINNER_OUTPUT=$("${cmd[@]}" 2>&1); then echo -e "${C_L_GREEN}Done.${T_RESET}" >&2; return 0
    else local exit_code=$?; echo -e "${C_RED}Failed.${T_RESET}" >&2
        while IFS= read -r line; do printf '    %s\n' "$line"; done <<< "$SPINNER_OUTPUT" >&2; return $exit_code; fi
}
_run_with_spinner_interactive() {
    local desc="$1"; shift; local cmd=("$@"); local temp_output_file; temp_output_file=$(mktemp)
    if [[ ! -f "$temp_output_file" ]]; then printErrMsg "Failed to create temp file."; return 1; fi
    local spinner_chars="⣾⣷⣯⣟⡿⢿⣻⣽"; local i=0; "${cmd[@]}" &> "$temp_output_file" &
    local pid=$!; tput civis; trap 'tput cnorm; rm -f "$temp_output_file"; exit 130' INT TERM
    while ps -p $pid > /dev/null; do
        echo -ne "\r\e[2K" >&2; local line; line=$(tail -n 1 "$temp_output_file" 2>/dev/null | tr -d '\r' || true)
        echo -ne " ${C_L_BLUE}${spinner_chars:$i:1}${T_RESET}  ${desc}" >&2
        if [[ -n "$line" ]]; then echo -ne " ${C_GRAY}[${line:0:70}]${T_RESET}" >&2; fi
        i=$(((i + 1) % ${#spinner_chars})); sleep 0.1; done
    wait $pid; local exit_code=$?; SPINNER_OUTPUT=$(<"$temp_output_file"); rm "$temp_output_file"
    tput cnorm; trap - INT TERM; clear_current_line >&2
    if [[ $exit_code -eq 0 ]]; then printOkMsg "${desc}" >&2
    else printErrMsg "Task failed: ${desc}" >&2
        while IFS= read -r line; do printf '    %s\n' "$line"; done <<< "$SPINNER_OUTPUT" >&2; fi
    return $exit_code
}
run_with_spinner() {
    if [[ ! -t 1 ]]; then _run_with_spinner_non_interactive "$@"; else _run_with_spinner_interactive "$@"; fi
}
wait_for_pids_with_spinner() {
    local desc="$1"; shift; local pids_to_wait_for=("$@")
    if [[ ! -t 1 ]]; then
        printMsgNoNewline "    ${T_INFO_ICON} ${desc}... " >&2
        if wait "${pids_to_wait_for[@]}"; then echo -e "${C_L_GREEN}Done.${T_RESET}" >&2; return 0
        else local exit_code=$?; echo -e "${C_RED}Failed (wait command exit code: $exit_code).${T_RESET}" >&2; return $exit_code; fi
    fi
    _spinner() {
        local spinner_chars="⣾⣷⣯⣟⡿⢿⣻⣽"; local i=0
        while true; do echo -ne "\r\e[2K" >&2; echo -ne "    ${C_L_BLUE}${spinner_chars:$i:1}${T_RESET} ${desc}" >&2; i=$(((i + 1) % ${#spinner_chars})); sleep 0.1; done
    }
    tput civis
    _spinner &
    local spinner_pid=$!
    trap 'kill "$spinner_pid" &>/dev/null; tput cnorm; exit 130' INT TERM
    wait "${pids_to_wait_for[@]}"; local exit_code=$?
    kill "$spinner_pid" &>/dev/null; tput cnorm; trap - INT TERM; clear_current_line >&2
    if [[ $exit_code -eq 0 ]]; then printOkMsg "${desc}" >&2
    else printErrMsg "Wait command failed with exit code ${exit_code} for task: ${desc}" >&2; fi
    return $exit_code
}

# --- Constants ---
SSH_DIR="${SSH_DIR:-${HOME}/.ssh}"
SSH_CONFIG_PATH="${SSH_CONFIG_PATH:-${SSH_DIR}/config}"
PORT_FORWARDS_CONFIG_PATH="${PORT_FORWARDS_CONFIG_PATH:-${SSH_DIR}/port_forwards.conf}"

# --- Script Functions ---

print_usage() {
    printBanner "SSH Connection Manager"
    printMsg "An interactive TUI to manage and connect to SSH hosts in:\n ${C_L_BLUE}${SSH_CONFIG_PATH}${T_RESET}"
    printMsg "\n${T_ULINE}Usage:${T_RESET}"
    printMsg "  $(basename "$0") [option]"
    printMsg "\nThis script is fully interactive.\nRun without arguments to launch the main menu."
    printMsg "\n${T_ULINE}Options:${T_RESET}"
    printMsg "  ${C_L_BLUE}-c, --connect${T_RESET}  Go directly to host selection for connecting"
    printMsg "  ${C_L_BLUE}-a, --add${T_RESET}      Go directly to the 'Add a new server' menu"
    printMsg "  ${C_L_BLUE}-p, --port-forward${T_RESET} Go directly to the 'Port Forwarding' menu"
    printMsg "  ${C_L_BLUE}-l, --list-hosts${T_RESET}    List all configured hosts and exit"
    printMsg "  ${C_L_BLUE}-f, --list-forwards${T_RESET}  List active port forwards and exit"
    printMsg "  ${C_L_BLUE}-t, --test [host|all]${T_RESET}  Test connection to a host, all hosts, or show menu"
    printMsg "  ${C_L_BLUE}-h, --help${T_RESET}     Show this help message"
}

# Parses the SSH config file to extract host aliases.
# Ignores wildcard hosts like '*'.
get_ssh_hosts() {
    if [[ ! -f "$SSH_CONFIG_PATH" ]]; then
        return
    fi
    # Use awk to find lines starting with "Host", print the second field,
    # and ignore any hosts that are just "*".
    awk '/^[Hh]ost / && $2 != "*" {print $2}' "$SSH_CONFIG_PATH"
}

# Gets a specific config value for a given host by using `ssh -G`.
# This is the most robust method as it uses ssh itself to evaluate the config.
# It correctly handles the "first value wins" rule for duplicate keys, as well
# as Match blocks and include directives.
# Usage: get_ssh_config_value <host_alias> <config_key>
get_ssh_config_value() {
    local host_alias="$1"
    local key="$2"
    local key_lower
    key_lower=$(echo "$key" | tr '[:upper:]' '[:lower:]')

    # `ssh -G` prints the fully resolved configuration for a host.
    ssh -G "$host_alias" 2>/dev/null | awk -v key="$key_lower" '
        $1 == key {
            # The value is the rest of the line. This handles values with spaces.
            val = ""
            for (i = 2; i <= NF; i++) {
                val = (val ? val " " : "") $i
            }
            print val
            exit
        }
    '
}

# (Private) Gets a config value ONLY if it's explicitly set in the host block.
# This avoids picking up default values that `ssh -G` provides.
# Returns an empty string if the key is not explicitly set in the block.
# Usage: _get_explicit_ssh_config_value <host_alias> <config_key>
_get_explicit_ssh_config_value() {
    local host_alias="$1"
    local key_lower
    key_lower=$(echo "$2" | tr '[:upper:]' '[:lower:]')

    local host_block
    host_block=$(_get_host_block_from_config "$host_alias" "$SSH_CONFIG_PATH")

    if [[ -n "$host_block" ]]; then
        # Parse the block for the specific key, ignoring case for the key itself.
        echo "$host_block" | awk -v key="$key_lower" '
            tolower($1) == key {
                val = ""; for (i = 2; i <= NF; i++) { val = (val ? val " " : "") $i }; print val; exit
            }
        '
    fi
}

# (Private) Gets all relevant config values for a given host in one go.
# Returns a string of `eval`-safe variable assignments.
# Usage:
#   local details; details=$(_get_all_ssh_config_values_as_string <host_alias>)
#   eval "$details"
_get_all_ssh_config_values_as_string() {
    local host_alias="$1"
    # Call ssh -G once per host and parse all required values in a single awk command.
    # This is much more efficient than calling ssh -G multiple times.
    ssh -G "$host_alias" 2>/dev/null | awk '
        # Map ssh -G output keys to the shell variable names we want to use.
        BEGIN {
            keys["hostname"] = "current_hostname"
            keys["user"] = "current_user"
            # identityfile is now handled separately to avoid ssh -G defaults
            keys["port"] = "current_port"
        }
        # If the first field is one of our target keys, process it.
        $1 in keys {
            var_name = keys[$1]
            # Reconstruct the value, which might contain spaces.
            val = ""
            for (i = 2; i <= NF; i++) { val = (val ? val " " : "") $i }
            # Print in KEY="VALUE" format for safe evaluation in the shell.
            printf "%s=\"%s\"\n", var_name, val
        }
    '
}

# Generates a list of formatted strings for the interactive menu,
# showing details for each SSH host.
# Populates an array whose name is passed as the first argument.
# Usage:
#   local -a my_menu_options
#   get_detailed_ssh_hosts_menu_options my_menu_options
get_detailed_ssh_hosts_menu_options() {
    local -n out_array="$1" # Use nameref to populate the caller's array
    local show_key_info="${2:-true}"
    local -a hosts
    mapfile -t hosts < <(get_ssh_hosts)

    out_array=() # Clear the output array

    if [[ ${#hosts[@]} -eq 0 ]]; then
        return 0 # Not an error, just no hosts
    fi

    for host_alias in "${hosts[@]}"; do
        # Declare local variables and use eval to populate them from the awk output.
        # This is safe because the input is controlled (from ssh -G) and the awk script
        # only processes specific, known keys.
        local current_hostname current_user current_identityfile current_port
        local details; details=$(_get_all_ssh_config_values_as_string "$host_alias") # Gets hostname, user, port
        eval "$details" # Sets the variables

        # Now, explicitly get the identity file to avoid using ssh -G defaults.
        current_identityfile=$(_get_explicit_ssh_config_value "$host_alias" "IdentityFile")

        # Clean up identity file path for display
        local key_info=""
        if [[ "$show_key_info" == "true" && -n "$current_identityfile" ]]; then
            # Using #$HOME is safer than a simple string replacement
            key_info=" (${C_WHITE}${current_identityfile/#$HOME/\~}${T_RESET})"
        fi

        # Format port info, only show if not the default port 22
        local port_info=""
        if [[ -n "$current_port" && "$current_port" != "22" ]]; then
            port_info=":${C_L_YELLOW}${current_port}${T_RESET}"
        fi

        local formatted_string
        formatted_string=$(printf "%-20s ${C_L_CYAN}%s@%s%s${T_RESET}%s" \
            "${host_alias}" \
            "${current_user:-?}" \
            "${current_hostname:-?}" \
            "${port_info}" \
            "${key_info}"
        )
        out_array+=("$formatted_string")
    done
}

# Presents an interactive menu for the user to select an SSH host.
# Returns the selected host alias via stdout.
# Returns exit code 1 if no host is selected or none exist.
# Usage:
#   local selected_host
#   selected_host=$(select_ssh_host "Select a host to connect to:")
#   if [[ $? -eq 0 ]]; then ...
select_ssh_host() {
    local prompt="$1"
    local show_key_info="${2:-true}"
    mapfile -t hosts < <(get_ssh_hosts)
    if [[ ${#hosts[@]} -eq 0 ]]; then
        printInfoMsg "No hosts found in your SSH config file."
        return 1
    fi

    local -a menu_options
    get_detailed_ssh_hosts_menu_options menu_options "$show_key_info"

    local selected_index
    local header
    header=$(printf "  %-20s ${C_WHITE}%s${T_RESET}" "HOST ALIAS" "user@hostname[:port]")
    selected_index=$(interactive_single_select_menu "$prompt" "$header" "${menu_options[@]}")
    if [[ $? -ne 0 ]]; then
        printInfoMsg "Operation cancelled."
        return 1
    fi

    echo "${hosts[$selected_index]}"
    return 0
}

# Helper function that does the actual ssh-copy-id work
copy_ssh_id_for_host() {
    local host_alias="$1"
    local key_file="$2"
    
    # By using the host_alias directly, ssh-copy-id will respect all settings
    # in the ~/.ssh/config file for that host, including User, HostName, and Port.
    # This is more robust than manually extracting values.
    printInfoMsg "Attempting to copy key to '${host_alias}'..."
    printMsg "You may be prompted for the password for the remote user."

    # ssh-copy-id is interactive, so we run it directly in the foreground.
    if ssh-copy-id -i "$key_file" "$host_alias"; then
        printOkMsg "Key successfully copied to '${host_alias}'."
    else
        printErrMsg "Failed to copy key to '${host_alias}'."
        printInfoMsg "Check your network connection, password, and server's SSH configuration."
        return 1
    fi
}

# Generates a new SSH key pair without associating it with a host.
generate_ssh_key() {
    printBanner "Generate New SSH Key"

    local -a key_types=("ed25519 (recommended)" "rsa (legacy, 4096 bits)")
    local selected_index
    selected_index=$(interactive_single_select_menu "Select the type of key to generate:" "" "${key_types[@]}")
    [[ $? -ne 0 ]] && { printInfoMsg "Operation cancelled."; return; }

    local key_type_selection="${key_types[$selected_index]}"
    local key_type="ed25519" # Default
    local key_bits_arg=""
    if [[ "$key_type_selection" == "rsa (legacy, 4096 bits)" ]]; then
        key_type="rsa"
        key_bits_arg="-b 4096"
    fi

    local key_filename
    prompt_for_input "Enter filename for the new key (in ${SSH_DIR})" key_filename "id_${key_type}" || return
    local full_key_path="${SSH_DIR}/${key_filename}"

    if [[ -f "$full_key_path" ]]; then
        if ! prompt_yes_no "Key file '${full_key_path}' already exists. Overwrite it?" "n"; then
            printInfoMsg "Key generation cancelled."
            return
        fi
    fi

    local key_comment
    prompt_for_input "Enter a comment for the key" key_comment "${USER}@$(hostname)" || return

    if run_with_spinner "Generating new ${key_type} key..." \
        ssh-keygen -t "${key_type}" ${key_bits_arg} -f "${full_key_path}" -N "" -C "${key_comment}"; then
        printInfoMsg "Key pair created:"
        printMsg "  Private key: ${C_L_BLUE}${full_key_path}${T_RESET}"
        printMsg "  Public key:  ${C_L_BLUE}${full_key_path}.pub${T_RESET}"
    else
        # run_with_spinner already prints the error details.
        printErrMsg "Failed to generate SSH key."
    fi
}

# Prompts user to select a host and then copies the specified key.
copy_selected_ssh_key() {
    local selected_key="$1"
    printBanner "Copy SSH Key to Server"
    printInfoMsg "Selected key: ${C_L_BLUE}${selected_key}${T_RESET}"

    local selected_host
    selected_host=$(select_ssh_host "Select a host to copy this key to:")
    [[ $? -ne 0 ]] && return

    copy_ssh_id_for_host "$selected_host" "$selected_key"
}

# Deletes an SSH key pair (private and public files).
delete_ssh_key() {
    local key_base_path="$1"
    local pub_key_path="${key_base_path}.pub"
    printBanner "Delete SSH Key Pair"

    if ! [[ -f "$key_base_path" ]]; then
        printErrMsg "Private key not found: ${key_base_path}"
        return 1
    fi

    local question="Are you sure you want to permanently delete this key pair?\n  Private: ${key_base_path}"
    if [[ -f "$pub_key_path" ]]; then
        question+="\n  Public:  ${pub_key_path}"
    else
        question+="\n  (Public key not found, will only delete private key)"
    fi

    if prompt_yes_no "$question" "n"; then
        if run_with_spinner "Deleting key pair..." rm -f "$key_base_path" "$pub_key_path"; then
            printOkMsg "Key pair deleted."
        else
            printErrMsg "Failed to delete key pair."
        fi
    else
        printInfoMsg "Deletion cancelled."
    fi
}

# Renames an SSH key pair.
rename_ssh_key() {
    local old_key_path="$1"
    printBanner "Rename SSH Key"
    local new_key_filename
    local old_filename; old_filename=$(basename "$old_key_path")
    prompt_for_input "Enter new filename for the key (in ${SSH_DIR})" new_key_filename "$old_filename" || return
    local new_key_path="${SSH_DIR}/${new_key_filename}"

    if [[ "$new_key_path" == "$old_key_path" ]]; then
        printInfoMsg "Filename is unchanged. No action taken."
        return
    fi
    if [[ -f "$new_key_path" || -f "${new_key_path}.pub" ]]; then
        printErrMsg "Target key file '${new_key_path}' or its .pub already exists. Aborting."
        return 1
    fi

    if run_with_spinner "Renaming key files..." _rename_key_pair "$old_key_path" "$new_key_path"; then
        printOkMsg "Key renamed successfully."
        printInfoMsg "Note: You must manually update any SSH host configs that used the old key name."
    else
        printErrMsg "Failed to rename key files."
        return 1
    fi
}

# Displays the content of a public key file.
view_public_key() {
    local pub_key_path="$1"
    printBanner "View Public Key"
    if [[ ! -f "$pub_key_path" ]]; then printErrMsg "Public key file not found: ${pub_key_path}"; return 1; fi
    printInfoMsg "Contents of ${C_L_BLUE}${pub_key_path}${T_RESET}:"
    printMsg "${C_GRAY}${DIV}${T_RESET}"
    printMsg "${C_L_GRAY}$(cat "${pub_key_path}")${T_RESET}"
    printMsg "${C_GRAY}${DIV}${T_RESET}"
}

# (Private) Worker for regenerating a public key, for use with run_with_spinner.
_regenerate_public_key_worker() {
    # ssh-keygen -y reads from the private key file and writes the public key to stdout.
    ssh-keygen -y -f "$1" > "$2"
}

# Re-generates a public key from a private key file.
regenerate_public_key() {
    local private_key_path="$1"
    local public_key_path="${private_key_path}.pub"
    printBanner "Re-generate Public Key"

    if [[ ! -f "$private_key_path" ]]; then
        printErrMsg "Private key not found: ${private_key_path}"
        return 1
    fi

    if [[ -f "$public_key_path" ]]; then
        if ! prompt_yes_no "Public key '${public_key_path}' already exists. Overwrite it?" "n"; then
            printInfoMsg "Operation cancelled."
            return
        fi
    fi

    if run_with_spinner "Re-generating public key..." _regenerate_public_key_worker "$private_key_path" "$public_key_path"; then
        printOkMsg "Public key successfully generated at: ${C_L_BLUE}${public_key_path}${T_RESET}"
    else
        printErrMsg "Failed to re-generate public key."
    fi
}

# An interactive prompt for user input that supports cancellation.
# It provides a rich line-editing experience including cursor movement
# (left/right/home/end), insertion, and deletion (backspace/delete).
# Usage: prompt_for_input "Prompt text" "variable_name" ["default_value"] ["allow_empty"]
# Returns 0 on success (Enter), 1 on cancellation (ESC).
prompt_for_input() {
    local prompt_text="$1"
    local -n var_ref="$2" # Use nameref to assign to caller's variable
    local default_val="${3:-}"
    local allow_empty="${4:-false}"

    # Pre-fill the input string with the default value.
    local input_str="$default_val"
    # Cursor position is the index of the character *before* which to insert.
    # 0 is the beginning, length is the end.
    local cursor_pos=${#input_str}
    local key

    while true; do
        # Draw the prompt and current input string.
        clear_current_line >/dev/tty
        printMsgNoNewline "${T_QST_ICON} ${prompt_text}: ${C_L_CYAN}${input_str}${T_RESET}" >/dev/tty

        # Move cursor to the correct position within the input string.
        # The cursor is currently at the end of the line. We need to move it
        # left by the number of characters that are *after* the cursor position.
        local chars_after_cursor=$(( ${#input_str} - cursor_pos ))
        if (( chars_after_cursor > 0 )); then
            # \e[<N>D moves cursor left N columns
            echo -ne "\e[${chars_after_cursor}D" >/dev/tty
        fi

        key=$(read_single_char </dev/tty)

        case "$key" in
            "$KEY_ENTER")
                # The final value is whatever is in the input buffer.
                local final_input="$input_str"
                if [[ -n "$final_input" || "$allow_empty" == "true" ]]; then
                    var_ref="$final_input"
                    clear_current_line >/dev/tty
                    # Show the prompt again with the final selected value.
                    printMsg "${T_QST_ICON} ${prompt_text}: ${C_L_GREEN}${final_input}${T_RESET}"
                    return 0 # Success
                fi
                # If not valid (empty and not allowed), loop continues.
                ;;
            "$KEY_ESC")
                clear_current_line >/dev/tty
                printMsg "${T_QST_ICON} ${prompt_text}:\n ${C_L_YELLOW}-- cancelled --${T_RESET}"
                return 1 # Cancelled
                ;;
            "$KEY_BACKSPACE")
                if (( cursor_pos > 0 )); then
                    # Remove character before the cursor
                    input_str="${input_str:0:cursor_pos-1}${input_str:cursor_pos}"
                    ((cursor_pos--))
                fi
                ;;
            "$KEY_DELETE")
                if (( cursor_pos < ${#input_str} )); then
                    # Remove character at the cursor
                    input_str="${input_str:0:cursor_pos}${input_str:cursor_pos+1}"
                    # cursor_pos does not change
                fi
                ;;
            "$KEY_LEFT")
                if (( cursor_pos > 0 )); then ((cursor_pos--)); fi
                ;;
            "$KEY_RIGHT")
                if (( cursor_pos < ${#input_str} )); then ((cursor_pos++)); fi
                ;;
            "$KEY_HOME")
                cursor_pos=0
                ;;
            "$KEY_END")
                cursor_pos=${#input_str}
                ;;
            *)
                # Append single, printable characters. Ignore control sequences.
                if (( ${#key} == 1 )) && [[ "$key" =~ [[:print:]] ]]; then
                    # Insert character at cursor position
                    input_str="${input_str:0:cursor_pos}${key}${input_str:cursor_pos}"
                    ((cursor_pos++))
                fi
                ;;
        esac
    done
}

# (Private) Handles the logic for selecting an existing key.
# Returns the path to the selected key via a nameref.
# Usage: _select_and_get_existing_key identity_file_var
# Returns 0 on success, 1 on cancellation/failure.
_select_and_get_existing_key() {
    local -n out_identity_file="$1"
    local -a pub_keys
    mapfile -t pub_keys < <(find "$SSH_DIR" -maxdepth 1 -type f -name "*.pub")
    if [[ ${#pub_keys[@]} -eq 0 ]]; then
        printErrMsg "No existing SSH keys (.pub files) found in ${SSH_DIR}."
        return 1
    fi

    local -a private_key_paths
    for pub_key in "${pub_keys[@]}"; do private_key_paths+=("${pub_key%.pub}"); done

    local key_idx
    key_idx=$(interactive_single_select_menu "Select the private key to use:" "" "${private_key_paths[@]}") || return 1
    out_identity_file="${private_key_paths[$key_idx]}"
    return 0
}

# (Private) Builds a host block as a string. Does not write to any file.
# Usage: _build_host_block_string <alias> <hostname> <user> <port> [identity_file]
_build_host_block_string() {
    local host_alias="$1"
    local host_name="$2"
    local user="$3"
    local port="$4"
    local identity_file="${5:-}"

    # Use a subshell to capture the output of multiple echo commands
    {
        echo "Host ${host_alias}"
        echo "    HostName ${host_name}"
        echo "    User ${user}"
        if [[ -n "$port" && "$port" != "22" ]]; then
            echo "    Port ${port}"
        fi
        if [[ -n "$identity_file" ]]; then
            echo "    IdentityFile ${identity_file}"
            echo "    IdentitiesOnly yes"
        fi
    }
}

# (Private) Appends a fully formed host block to the SSH config file.
# Usage: _append_host_to_config <alias> <hostname> <user> <port> [identity_file]
_append_host_to_config() {
    local host_alias="$1"
    local host_name="$2"
    local user="$3"
    local port="$4"
    local identity_file="${5:-}"

    (
        echo "" # Separator
        _build_host_block_string "$host_alias" "$host_name" "$user" "$port" "$identity_file"
    ) >> "$SSH_CONFIG_PATH"

    local key_msg=""
    if [[ -n "$identity_file" ]]; then
        key_msg=" with key ${identity_file/#$HOME/\~}"
    fi
    printOkMsg "Host '${host_alias}' added to ${SSH_CONFIG_PATH}${key_msg}."
}

# (Private) Prompts for a new, unique SSH host alias.
# It allows the user to re-enter an existing alias, which is treated as a no-op if it's the "old" one.
# Uses a nameref to return the value.
# Usage: _prompt_for_unique_host_alias alias_var [prompt_text] [old_alias_to_allow] [default_value]
# Returns 0 on success, 1 on cancellation.
_prompt_for_unique_host_alias() {
    local out_alias_var_name="$1"
    local -n out_alias_var="$out_alias_var_name" # Use a nameref for easier value access/modification internally.
    local prompt_text="${2:-Enter a short alias for the host}"
    local old_alias_to_allow="${3:-}"
    local default_value="${4:-}"

    while true; do
        # Pass the default value, which might be the old alias or the user's previous (invalid) input.
        prompt_for_input "$prompt_text" "$out_alias_var_name" "$default_value" || return 1

        # If renaming and the user entered the old name, it's a valid "no-op" choice.
        if [[ -n "$old_alias_to_allow" && "$out_alias_var" == "$old_alias_to_allow" ]]; then
            return 0
        fi

        # Check if host alias already exists in the main config file.
        if get_ssh_hosts | grep -qFx "$out_alias_var"; then
            printErrMsg "Host alias '${out_alias_var}' already exists. Please choose another."
            # Set the default for the next loop iteration to what the user just typed.
            default_value="$out_alias_var"
        else
            return 0 # Alias is unique, success
        fi
    done
}

# (Private) A generic, reusable interactive loop for the host editors.
# This function encapsulates the shared UI loop for adding, editing, and cloning hosts,
# significantly reducing code duplication.
#
# It modifies the 'new_*' variables in the caller's scope via namerefs.
#
# Usage: _interactive_host_editor_loop <mode> <banner> <n_alias_var> ... <o_alias> ...
# Returns 0 if the user chooses to save, 1 if they cancel/quit.
_interactive_host_editor_loop() {
    local mode="$1"
    local banner_text="$2"
    # These are the *names* of the variables in the caller's scope.
    local p_alias="$3" p_hostname="$4" p_user="$5" p_port="$6" p_identityfile="$7"
    # Use namerefs internally for easier access to the values.
    local -n n_alias="$p_alias" n_hostname="$p_hostname" n_user="$p_user" n_port="$p_port" n_identityfile="$p_identityfile"
    # Original values are passed by value for comparison.
    local original_alias="$8" original_hostname="$9" original_user="${10}" original_port="${11}" original_identityfile="${12}"

    while true; do
        clear
        printBanner "$banner_text"
        _draw_interactive_host_editor_ui "$mode" "$n_alias" "$n_hostname" "$n_user" "$n_port" "$n_identityfile" \
                                         "$original_alias" "$original_hostname" "$original_user" "$original_port" "$original_identityfile"

        local key; key=$(read_single_char)
        case "$key" in
            '1')
                # Edit Alias
                local prompt="Enter a short alias for the host"
                local old_alias_to_allow=""
                if [[ "$mode" == "edit" ]]; then prompt="Enter the new alias for the host"; old_alias_to_allow="$original_alias"; fi
                if [[ "$mode" == "clone" ]]; then prompt="Enter the new alias for the cloned host"; fi
                _prompt_for_unique_host_alias "$p_alias" "$prompt" "$old_alias_to_allow" "$n_alias"
                ;;
            '2') prompt_for_input "HostName" "$p_hostname" "$n_hostname" ;;
            '3') prompt_for_input "User" "$p_user" "$n_user" ;;
            '4') prompt_for_input "Port" "$p_port" "$n_port" ;;
            '5') clear_current_line; _prompt_for_identity_file_interactive "$p_identityfile" "$n_identityfile" "$n_alias" "$n_user" "$n_hostname" ;;
            'c'|'C'|'d'|'D')
                # Discard/Reset
                clear_current_line
                local question="Discard all pending changes?"
                if [[ "$mode" == "add" ]]; then question="Discard all changes and reset fields?"; fi
                if prompt_yes_no "$question" "y"; then
                    n_alias="$original_alias"; n_hostname="$original_hostname"; n_user="$original_user"; n_port="$original_port"; n_identityfile="$original_identityfile"
                    printInfoMsg "Changes discarded."; sleep 1
                fi ;;
            's'|'S') return 0 ;; # Signal to Save
            'q'|'Q'|"$KEY_ESC")
                # Quit
                local expanded_new_idfile="${n_identityfile/#\~/$HOME}"; local expanded_orig_idfile="${original_identityfile/#\~/$HOME}"
                if [[ "$n_alias" != "$original_alias" || "$n_hostname" != "$original_hostname" || "$n_user" != "$original_user" || "$n_port" != "$original_port" || "$expanded_new_idfile" != "$expanded_orig_idfile" ]]; then
                    clear_current_line
                    if prompt_yes_no "You have unsaved changes. Quit without saving?" "n"; then
                        printInfoMsg "Operation cancelled."; sleep 1; return 1
                    fi
                else
                    return 1 # No changes, just quit
                fi ;;
        esac
    done
}

# Prompts user for details and adds a new host to the SSH config.
add_ssh_host() {
    printBanner "Add New SSH Host"

    # --- Step 1: Choose to create from scratch or clone ---
    local -a add_options=("Create a new host from scratch" "Clone settings from an existing host")
    local add_choice_idx
    add_choice_idx=$(interactive_single_select_menu "How would you like to add the new host?" "" "${add_options[@]}")
    if [[ $? -ne 0 ]]; then printInfoMsg "Host creation cancelled."; return; fi

    # --- Step 2: Set initial values ---
    local initial_alias="" initial_hostname="" initial_user="$USER" initial_port="22" initial_identityfile=""
    local creation_mode="scratch"
    local host_to_clone=""
    if [[ "${add_options[$add_choice_idx]}" == "Clone settings from an existing host" ]]; then
        host_to_clone=$(select_ssh_host "Select a host to clone settings from:")
        if [[ $? -ne 0 ]]; then return; fi
        creation_mode="clone"

        local i=1; while true; do
            local proposed_alias="${host_to_clone}-clone"; [[ $i -gt 1 ]] && proposed_alias+="-${i}"
            if ! get_ssh_hosts | grep -qFx "$proposed_alias"; then initial_alias="$proposed_alias"; break; fi; ((i++))
        done
        initial_hostname=$(get_ssh_config_value "$host_to_clone" "HostName")
        initial_user=$(get_ssh_config_value "$host_to_clone" "User")
        initial_port=$(get_ssh_config_value "$host_to_clone" "Port")
        initial_identityfile=$(_get_explicit_ssh_config_value "$host_to_clone" "IdentityFile")
        [[ -z "$initial_port" ]] && initial_port="22"
    fi

    local new_alias="$initial_alias" new_hostname="$initial_hostname" new_user="$initial_user" new_port="$initial_port" new_identityfile="$initial_identityfile"

    local banner_text="Add New SSH Host"
    if [[ "$creation_mode" == "clone" ]]; then banner_text="Add New Host (cloned from ${C_L_CYAN}${host_to_clone}${C_BLUE})"; fi

    # Call the shared editor loop. It will modify the 'new_*' variables.
    if ! _interactive_host_editor_loop "add" "$banner_text" \
        new_alias new_hostname new_user new_port new_identityfile \
        "$initial_alias" "$initial_hostname" "$initial_user" "$initial_port" "$initial_identityfile"; then
        return # User cancelled
    fi

    # --- Save Logic (executed if the loop returns 0) ---
    if [[ -z "$new_alias" || -z "$new_hostname" ]]; then printErrMsg "Host Alias and HostName cannot be empty."; sleep 2; return 1; fi
    if get_ssh_hosts | grep -qFx "$new_alias"; then printErrMsg "Host alias '${new_alias}' already exists."; sleep 2; return 1; fi

    _append_host_to_config "$new_alias" "$new_hostname" "$new_user" "$new_port" "$new_identityfile"

    if [[ -n "$new_identityfile" ]]; then
        local default_copy="n"; [[ "$creation_mode" == "scratch" ]] && default_copy="y"
        if prompt_yes_no "Copy public key to the new server now?" "$default_copy"; then copy_ssh_id_for_host "$new_alias" "${new_identityfile}.pub"; fi
    fi
    if prompt_yes_no "Test the connection to '${new_alias}' now?" "y"; then echo; _test_connection_for_host "$new_alias"; fi
}

# (Private) Generic function to process an SSH config file, filtering host blocks.
# It can either keep only the matching block or remove it and keep everything else.
# Usage: _process_ssh_config_blocks <target_host> <config_file> <mode>
#   mode: 'keep' - prints only the block matching the target_host.
#   mode: 'remove' - prints the entire file except for the matching block.
_process_ssh_config_blocks() {
    local target_host="$1"
    local config_file="$2"
    local mode="$3" # 'keep' or 'remove'

    if [[ "$mode" != "keep" && "$mode" != "remove" ]]; then
        printErrMsg "Invalid mode '${mode}' for _process_ssh_config_blocks" >&2
        return 1
    fi

    awk -v target_host="$target_host" -v mode="$mode" '
        # Flushes the buffered block based on whether it matches the target and the desired mode.
        # It manages a single newline separator between printed blocks.
        function flush_block() {
            if (block != "") {
                if ((mode == "keep" && is_target_block) || (mode == "remove" && !is_target_block)) {
                    # If we have printed a block before, add a newline separator.
                    if (output_started) {
                        printf "\n"
                    }
                    printf "%s", block
                    output_started = 1
                }
            }
        }

        # Match a new Host block definition.
        /^[ \t]*[Hh][Oo][Ss][Tt][ \t]+/ {
            flush_block() # Flush the previous block.

            # Reset state for the new block.
            block = $0
            is_target_block = 0

            # Check if this new block is the one we are looking for by iterating
            # through the fields on the line, starting from the second field.
            for (i = 2; i <= NF; i++) {
                if ($i ~ /^#/) break # Stop at the first comment
                if ($i == target_host) {
                    is_target_block = 1
                    break
                }
            }
            next
        }

        # For any other line (part of a block, a comment, or a blank line):
        {
            if (block != "") {
                block = block "\n" $0
            } else {
                # This is content before the first Host definition.
                # It is never a target block, so print it only in "remove" mode.
                if (mode == "remove") {
                    printf "%s\n", $0
                    output_started = 1
                }
            }
        }

        # At the end of the file, flush the last remaining block.
        END {
            flush_block()
            if (output_started) {
                printf "\n"
            }
        }
    ' "$config_file"
}

# (Private) Reads the SSH config and returns a new version with a specified host block removed.
# Usage:
#   local new_config
#   new_config=$(_remove_host_block_from_config "my-host")
#   echo "$new_config" > "$SSH_CONFIG_PATH"
_remove_host_block_from_config() {
    local host_to_remove="$1"
    _process_ssh_config_blocks "$host_to_remove" "$SSH_CONFIG_PATH" "remove"
}

# (Private) Reads an SSH config file and returns the block for a specific host.
# Usage:
#   local block
#   block=$(_get_host_block_from_config "my-host" "/path/to/config")
_get_host_block_from_config() {
    local host_to_find="$1"
    local config_file="$2"
    _process_ssh_config_blocks "$host_to_find" "$config_file" "keep"
}

# (Private) Interactively prompts the user to select or create an IdentityFile when editing a host.
# This provides a menu-driven alternative to manually typing a file path.
# Usage: _prompt_for_identity_file_interactive <out_var> <current_path> <host_alias> <user> <hostname>
# Returns 0 on success, 1 on cancellation.
_prompt_for_identity_file_interactive() {
    local -n out_identity_file="$1"
    local current_identity_file="$2"
    local host_alias="$3"
    local user="$4"
    local hostname="$5"

    while true; do
        local -a menu_options=()
        local -a option_values=() # Parallel array to hold the real values

        # Option: Keep current
        if [[ -n "$current_identity_file" ]]; then
            menu_options+=("Keep current: ${C_L_GREEN}${current_identity_file/#$HOME/\~}${T_RESET}")
            option_values+=("$current_identity_file")
        fi

        # Option: Remove
        menu_options+=("Remove IdentityFile entry")
        option_values+=("__REMOVE__")

        # Option: Generate new
        menu_options+=("Generate a new dedicated key (ed25519)...")
        option_values+=("__GENERATE__")

        # Find existing private keys to offer as choices
        local -a existing_keys=()
        mapfile -t pub_keys < <(find "$SSH_DIR" -maxdepth 1 -type f -name "*.pub")
        if [[ ${#pub_keys[@]} -gt 0 ]]; then
            for pub_key in "${pub_keys[@]}"; do
                local private_key="${pub_key%.pub}"
                # Only add if it's not the currently selected key
                if [[ "$private_key" != "$current_identity_file" ]]; then
                    existing_keys+=("$private_key")
                fi
            done
        fi

        if [[ ${#existing_keys[@]} -gt 0 ]]; then
            menu_options+=("--- Select an existing key ---")
            option_values+=("__SEPARATOR__")
            for key in "${existing_keys[@]}"; do
                menu_options+=("  ${key/#$HOME/\~}")
                option_values+=("$key")
            done
        fi

        local selected_index
        selected_index=$(interactive_single_select_menu "Select an IdentityFile option for '${host_alias}':" "" "${menu_options[@]}")
        if [[ $? -ne 0 ]]; then return 1; fi # User cancelled

        local selected_value="${option_values[$selected_index]}"

        case "$selected_value" in
            "__SEPARATOR__") continue ;; # Loop to redraw menu
            "__REMOVE__") out_identity_file=""; return 0 ;;
            "__GENERATE__")
                local new_key_filename; local default_key_name="${host_alias}_id_ed25519"
                prompt_for_input "Enter filename for new key (in ${SSH_DIR})" new_key_filename "$default_key_name" || continue
                local new_key_path="${SSH_DIR}/${new_key_filename}"
                if [[ -f "$new_key_path" ]] && ! prompt_yes_no "Key file '${new_key_path}' already exists.\n    Overwrite?" "n"; then
                    printInfoMsg "Key generation cancelled."; continue
                fi
                if run_with_spinner "Generating new ed25519 key..." ssh-keygen -t ed25519 -f "$new_key_path" -N "" -C "${user}@${hostname}"; then
                    out_identity_file="$new_key_path"; return 0
                else printErrMsg "Failed to generate key."; prompt_to_continue; continue; fi ;;
            *) out_identity_file="$selected_value"; return 0 ;;
        esac
    done
}

# (Private) Generic UI for the interactive host editors (add, edit, clone).
# This single function replaces _draw_interactive_add_host_ui, _draw_interactive_edit_host_ui,
# and _draw_interactive_clone_host_ui, reducing code duplication.
# Usage: _draw_interactive_host_editor_ui <mode> <new_alias> <new_hostname> ... <original_alias> ...
_draw_interactive_host_editor_ui() {
    local mode="$1"
    local new_alias="$2" new_hostname="$3" new_user="$4" new_port="$5" new_identityfile="$6"
    local original_alias="$7" original_hostname="$8" original_user="$9" original_port="${10}" original_identityfile="${11}"

    # Helper to format a line, adding a change indicator (*) if needed.
    _format_line() {
        local key="$1" label="$2" new_val="$3" original_val="$4" is_alias="${5:-false}"

        local display_val="${new_val}"; if [[ "$label" == "IdentityFile" ]]; then display_val="${new_val/#$HOME/\~}"; fi
        if [[ -z "$display_val" ]]; then display_val="${C_GRAY}(not set)${T_RESET}"; else display_val="${C_L_CYAN}${display_val}${T_RESET}"; fi

        local change_indicator=" "
        # In 'add' mode, there are no "changes" from an original, so no indicator.
        if [[ "$mode" != "add" ]]; then
            if [[ "$is_alias" == "true" ]]; then
                if [[ "$new_val" != "$original_val" ]]; then change_indicator="${C_L_YELLOW}*${T_RESET}"; fi
            else
                local expanded_new_val="${new_val/#\~/$HOME}"
                if [[ "$expanded_new_val" != "${original_val/#\~/$HOME}" ]]; then change_indicator="${C_L_YELLOW}*${T_RESET}"; fi
            fi
        fi

        # For clone mode, the alias is always considered a change.
        if [[ "$mode" == "clone" && "$label" == "Host (Alias)" ]]; then change_indicator="${C_L_YELLOW}*${T_RESET}"; fi

        printf "  ${C_L_WHITE}%s)${T_RESET} %b %-15s: %b\n" "$key" "$change_indicator" "$label" "$display_val"
    }

    local title="Configure the host details:"
    if [[ "$mode" == "add" ]]; then title="Configure the new host:"; fi
    if [[ "$mode" == "clone" ]]; then title="Configure the new cloned host:"; fi
    printMsg "$title"

    _format_line "1" "Host (Alias)" "$new_alias" "$original_alias" "true"
    _format_line "2" "HostName"     "$new_hostname" "$original_hostname"
    _format_line "3" "User"         "$new_user" "$original_user"
    _format_line "4" "Port"         "$new_port" "$original_port"
    _format_line "5" "IdentityFile" "$new_identityfile" "$original_identityfile"

    echo
    local discard_text="iscard all pending changes"
    if [[ "$mode" == "add" ]]; then discard_text="eset fields"; fi
    printMsg "  ${C_L_WHITE}c) ${C_L_YELLOW}(C)ancel/(D)${discard_text}${T_RESET}"
    printMsg "  ${C_L_WHITE}s) ${C_L_GREEN}(S)ave${T_RESET} and Quit"
    printMsg "  ${C_L_WHITE}q) ${C_L_YELLOW}(Q)uit${T_RESET} without saving (or press ${C_L_YELLOW}ESC${T_RESET})"
    echo
    printMsgNoNewline "${T_QST_ICON} Your choice: "
}

# Edits an existing host in the SSH config.
edit_ssh_host() {
    printBanner "Edit SSH Host"

    local original_alias="$1"
    if [[ -z "$original_alias" ]]; then
        original_alias=$(select_ssh_host "Select a host to edit:")
        [[ $? -ne 0 ]] && return
    fi

    # Get original values to compare against for changes.
    local original_hostname original_user original_port original_identityfile
    local details; details=$(_get_all_ssh_config_values_as_string "$original_alias")
    # Use parameter expansion to rename the 'current_*' variables from the helper to 'original_*'.
    eval "${details//current/original}" # Sets original_hostname, original_user, original_port
    original_identityfile=$(_get_explicit_ssh_config_value "$original_alias" "IdentityFile")
    [[ -z "$original_port" ]] && original_port="22"

    # These variables will hold the values as they are being edited.
    local new_alias="$original_alias" new_hostname="$original_hostname" new_user="$original_user" new_port="$original_port" new_identityfile="$original_identityfile"

    local banner_text="Edit SSH Host - ${C_L_CYAN}${original_alias}${C_BLUE}"
    if ! _interactive_host_editor_loop "edit" "$banner_text" \
        new_alias new_hostname new_user new_port new_identityfile \
        "$original_alias" "$original_hostname" "$original_user" "$original_port" "$original_identityfile"; then
        return # User cancelled
    fi

    # --- Save Logic ---
    local expanded_new_idfile="${new_identityfile/#\~/$HOME}"; local expanded_orig_idfile="${original_identityfile/#\~/$HOME}"
    if [[ "$new_alias" == "$original_alias" && "$new_hostname" == "$original_hostname" && "$new_user" == "$original_user" && "$new_port" == "$original_port" && "$expanded_new_idfile" == "$expanded_orig_idfile" ]]; then
        printInfoMsg "No changes detected. Host configuration remains unchanged."; sleep 1; return
    fi

    # --- Key File Renaming/Copying Logic (if alias changed) ---
    if [[ "$new_alias" != "$original_alias" && -n "$new_identityfile" ]]; then
        local expanded_old_key_path="${new_identityfile/#\~/$HOME}"
        if [[ -f "$expanded_old_key_path" ]]; then
            local -a hosts_sharing_key=(); mapfile -t all_hosts < <(get_ssh_hosts)
            for other_host in "${all_hosts[@]}"; do
                if [[ "$other_host" != "$original_alias" ]]; then
                    local other_host_key; other_host_key=$(_get_explicit_ssh_config_value "$other_host" "IdentityFile")
                    if [[ "$other_host_key" == "$new_identityfile" ]]; then hosts_sharing_key+=("$other_host"); fi
                fi
            done
            local proposed_new_key_path="${SSH_DIR}/${new_alias}_id_ed25519"
            if [[ ${#hosts_sharing_key[@]} -gt 0 ]]; then
                local question="The key '${new_identityfile}' is shared by other hosts.\n    Do you want to create a dedicated COPY of this key for '${new_alias}'?\n    New key path: ${C_L_BLUE}${proposed_new_key_path}${T_RESET}"
                if prompt_yes_no "$question" "y"; then
                    if [[ -f "$proposed_new_key_path" || -f "${proposed_new_key_path}.pub" ]]; then printErrMsg "Cannot create key copy: target file '${proposed_new_key_path}' or its .pub already exists."
                    elif run_with_spinner "Copying key files..." _copy_key_pair "$expanded_old_key_path" "$proposed_new_key_path"; then new_identityfile="$proposed_new_key_path"
                    else printErrMsg "Failed to copy key files. The host was not changed."; sleep 2; return 1; fi
                fi
            elif [[ "$expanded_old_key_path" != "$proposed_new_key_path" ]]; then
                local question="This host uses the key:\n    ${C_L_BLUE}${new_identityfile/#\~/$HOME}${T_RESET}\nDo you want to rename this key to match the new host alias?\n    New name: ${C_L_BLUE}${proposed_new_key_path}${T_RESET}"
                if prompt_yes_no "$question" "y"; then
                    if [[ -f "$proposed_new_key_path" || -f "${proposed_new_key_path}.pub" ]]; then printErrMsg "Cannot rename key: target file '${proposed_new_key_path}' or its .pub already exists."
                    elif run_with_spinner "Renaming key files..." _rename_key_pair "$expanded_old_key_path" "$proposed_new_key_path"; then new_identityfile="$proposed_new_key_path"
                    else printErrMsg "Failed to rename key files. The host was not changed."; sleep 2; return 1; fi
                fi
            fi
        fi
    fi

    local config_without_host; config_without_host=$(_remove_host_block_from_config "$original_alias")
    local new_host_block; new_host_block=$(_build_host_block_string "$new_alias" "$new_hostname" "$new_user" "$new_port" "$new_identityfile")
    echo -e "${config_without_host}\n\n${new_host_block}" | cat -s > "$SSH_CONFIG_PATH"
    printOkMsg "Host '${original_alias}' has been updated to '${new_alias}'."

    if [[ -n "$original_identityfile" && "$expanded_new_idfile" != "$expanded_orig_idfile" ]]; then
        _cleanup_orphaned_key "$original_identityfile"
    fi
}

# Allows advanced editing of a host's config block directly in $EDITOR.
edit_ssh_host_in_editor() {
    printBanner "Edit Host Block in Editor"

    local host_to_edit="$1"
    if [[ -z "$host_to_edit" ]]; then
        host_to_edit=$(select_ssh_host "Select a host to edit:")
        [[ $? -ne 0 ]] && return # select_ssh_host prints messages
    fi

    # Get the original block content
    local original_block
    original_block=$(_get_host_block_from_config "$host_to_edit" "$SSH_CONFIG_PATH")

    if [[ -z "$original_block" ]]; then
        printErrMsg "Could not find a configuration block for '${host_to_edit}'."
        return 1
    fi

    # Create a temporary file to hold the block for editing
    local temp_file
    # Use a suffix that editors like Vim/Neovim will recognize for ssh_config syntax highlighting.
    temp_file=$(mktemp --suffix=.sshconfig)
    # Ensure temp file is cleaned up on exit or interrupt
    trap 'rm -f "$temp_file"' RETURN

    # Add a Vim/Neovim modeline to the top of the temp file to explicitly set the filetype.
    # This is more reliable than relying on just the filename extension.
    # The modeline will be stripped out before saving.
    echo "# vim: set filetype=sshconfig:" > "$temp_file"
    echo "$original_block" >> "$temp_file"

    # Determine the editor to use
    local editor="${EDITOR:-nvim}"
    if ! command -v "${editor}" &>/dev/null; then
        printErrMsg "Editor '${editor}' not found. Please set the EDITOR environment variable."
        return 1
    fi

    printInfoMsg "Opening '${host_to_edit}' in '${editor}'..."
    printInfoMsg "(Save and close the editor to apply changes,\n    or exit without saving to cancel)"
    # Give the user a moment to read the message before launching the editor.
    prompt_to_continue

    # clear out the instructions
    clear_lines_up 3
    # Open the temp file in the editor. This is a blocking call.
    "${editor}" "$temp_file"

    # Read the potentially modified content
    local new_block
    # Strip the modeline we added. The rest is the user's content.
    new_block=$(grep -v "vim: set filetype=sshconfig:" "$temp_file")

    # Command substitution `$(...)` strips trailing newlines from both original_block and new_block,
    # making them directly comparable if no changes were made.
    if [[ "$new_block" == "$original_block" ]]; then
        printInfoMsg "No changes detected. Configuration for '${host_to_edit}' remains unchanged."
        return
    fi

    # Get the config content without the old host block and append the new one
    local config_without_host
    config_without_host=$(_remove_host_block_from_config "$host_to_edit")
    echo -e "${config_without_host}\n\n${new_block}" | cat -s > "$SSH_CONFIG_PATH"

    printOkMsg "Host '${host_to_edit}' has been updated from editor."
}

# Clones an existing SSH host configuration to a new alias using an interactive UI.
clone_ssh_host() {
    local host_to_clone="$1"
    if [[ -z "$host_to_clone" ]]; then
        printBanner "Clone SSH Host"
        host_to_clone=$(select_ssh_host "Select a host to clone:")
        [[ $? -ne 0 ]] && return # select_ssh_host prints messages
    fi

    # Get original values from the source host.
    local original_hostname original_user original_port original_identityfile
    local details; details=$(_get_all_ssh_config_values_as_string "$host_to_clone")
    eval "${details//current/original}" # Sets original_hostname, original_user, original_port
    original_identityfile=$(_get_explicit_ssh_config_value "$host_to_clone" "IdentityFile")
    [[ -z "$original_port" ]] && original_port="22"

    # These variables will hold the values for the new cloned host.
    local new_hostname="$original_hostname" new_user="$original_user" new_port="$original_port" new_identityfile="$original_identityfile"
    # Propose a unique new alias.
    local new_alias i=1
    while true; do
        local proposed_alias="${host_to_clone}-clone"; [[ $i -gt 1 ]] && proposed_alias+="-${i}"
        if ! get_ssh_hosts | grep -qFx "$proposed_alias"; then new_alias="$proposed_alias"; break; fi
        ((i++))
    done

    local banner_text="Clone Host from ${C_L_CYAN}${host_to_clone}${C_BLUE}"
    if ! _interactive_host_editor_loop "clone" "$banner_text" \
        new_alias new_hostname new_user new_port new_identityfile \
        "$new_alias" "$original_hostname" "$original_user" "$original_port" "$original_identityfile"; then
        return # User cancelled
    fi

    # --- Save Logic ---
    if get_ssh_hosts | grep -qFx "$new_alias"; then printErrMsg "Host alias '${new_alias}' already exists."; sleep 2; return 1; fi

    _append_host_to_config "$new_alias" "$new_hostname" "$new_user" "$new_port" "$new_identityfile"

    if [[ -n "$new_identityfile" ]] && prompt_yes_no "Copy public key to the new server now?" "n"; then
        copy_ssh_id_for_host "$new_alias" "${new_identityfile}.pub"
    fi
}

# (Private) The worker function that performs the file re-ordering.
# This is separated to be used with `run_with_spinner`.
# It assumes a backup has already been made.
_reorder_ssh_hosts_worker() {
    local backup_file="$1"
    shift
    local -a new_ordered_hosts=("$@")

    # 1. Extract header (content before any Host block) from the backup.
    local header_content
    header_content=$(awk '/^[ \t]*[Hh][Oo][Ss][Tt][ \t]/ {exit} 1' "$backup_file")

    # 2. Extract the footer (Host * block) from the backup, if it exists.
    local footer_content
    footer_content=$(_get_host_block_from_config "*" "$backup_file")

    # 3. Extract all managed host blocks from the backup into a map.
    local -A host_blocks
    mapfile -t original_hosts < <(get_ssh_hosts) # Read from original config to get keys
    for host in "${original_hosts[@]}"; do
        host_blocks["$host"]=$(_get_host_block_from_config "$host" "$backup_file")
    done

    # 4. Overwrite the original config file by assembling the pieces.
    # Start with the header.
    echo -n "$header_content" > "$SSH_CONFIG_PATH"

    # Append the re-ordered managed host blocks.
    for host in "${new_ordered_hosts[@]}"; do
        # Ensure there's a newline before appending each block.
        echo -e "\n${host_blocks[$host]}" >> "$SSH_CONFIG_PATH"
    done

    # Append the footer if it existed.
    if [[ -n "$footer_content" ]]; then
        echo -e "\n${footer_content}" >> "$SSH_CONFIG_PATH"
    fi

    # 5. Clean up multiple blank lines that may have been introduced.
    local temp_file; temp_file=$(mktemp)
    cat -s "$SSH_CONFIG_PATH" > "$temp_file" && mv "$temp_file" "$SSH_CONFIG_PATH"
}

# Allows the user to interactively re-order the host blocks in the config file.
reorder_ssh_hosts() {
    printBanner "Re-order SSH Hosts"
    mapfile -t original_hosts < <(get_ssh_hosts)
    if [[ ${#original_hosts[@]} -lt 2 ]]; then
        printInfoMsg "Fewer than two hosts found. Nothing to re-order."
        return
    fi

    local reordered_output
    reordered_output=$(interactive_reorder_menu "Re-order hosts:" "${original_hosts[@]}")
    [[ $? -ne 0 ]] && { printInfoMsg "Re-ordering cancelled."; return; }
    mapfile -t new_ordered_hosts <<< "$reordered_output"

    if [[ "${new_ordered_hosts[*]}" == "${original_hosts[*]}" ]]; then
        printInfoMsg "Order is unchanged. No action taken."
        return
    fi

    printWarnMsg "This action will rewrite your SSH config file to apply the new order."
    if ! prompt_yes_no "This may lose comments between hosts. A backup will be created.\n    Continue with re-ordering?" "n"; then
        printInfoMsg "Re-ordering cancelled."
        return
    fi

    # Create a backup first.
    local backup_dir="${SSH_DIR}/backups"; mkdir -p "$backup_dir"
    local timestamp; timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
    local backup_file="${backup_dir}/config_reorder_${timestamp}.bak"
    cp "$SSH_CONFIG_PATH" "$backup_file"
    printInfoMsg "Backup created at: ${C_L_BLUE}${backup_file}${T_RESET}"

    if run_with_spinner "Applying new host order..." \
        _reorder_ssh_hosts_worker "$backup_file" "${new_ordered_hosts[@]}"; then
        printOkMsg "SSH config file has been re-ordered successfully."
    else
        printErrMsg "Failed to re-order hosts. Your original config is safe."
        printInfoMsg "The backup of your config is available at: ${backup_file}"
    fi
}

# (Private) Helper function to rename both private and public key files.
# This is designed to be called by `run_with_spinner`.
# Usage: _rename_key_pair <old_base_path> <new_base_path>
_rename_key_pair() {
    local old_base="$1"
    local new_base="$2"
    # The `&&` ensures we only try to move the public key if the private key move succeeds.
    mv "${old_base}" "${new_base}" && mv "${old_base}.pub" "${new_base}.pub"
}

# (Private) Helper function to copy both private and public key files.
# This is designed to be called by `run_with_spinner`.
# Usage: _copy_key_pair <source_base_path> <dest_base_path>
_copy_key_pair() {
    local source_base="$1"
    local dest_base="$2"
    cp "${source_base}" "${dest_base}" && cp "${source_base}.pub" "${dest_base}.pub"
}

# (Private) Checks for and offers to remove an orphaned key file.
# An orphaned key is one that is no longer referenced by any host in the SSH config.
# This is typically called after a host has been removed from the config.
# Usage: _cleanup_orphaned_key <path_to_key_file>
_cleanup_orphaned_key() {
    local key_file_path="$1"

    # 1. If no key file was associated with the host, there's nothing to do.
    if [[ -z "$key_file_path" ]]; then
        return
    fi

    # 2. Expand tilde to full path for checks.
    local expanded_key_path="${key_file_path/#\~/$HOME}"

    # 3. Check if the key file actually exists.
    if [[ ! -f "$expanded_key_path" ]]; then
        return
    fi

    # 4. Check if any other host in the *current* config uses this key.
    mapfile -t remaining_hosts < <(get_ssh_hosts)
    for host in "${remaining_hosts[@]}"; do
        local host_key_file; host_key_file=$(get_ssh_config_value "$host" "IdentityFile")
        local expanded_host_key_file="${host_key_file/#\~/$HOME}"

        if [[ "$expanded_host_key_file" == "$expanded_key_path" ]]; then
            printInfoMsg "The key '${key_file_path}' is still in use by host '${host}'. It will not be removed."
            return # Key is in use, so we're done.
        fi
    done

    # 5. If we get here, the key is not used by any other host. Prompt for deletion.
    if prompt_yes_no "The key '${key_file_path}' is no longer referenced by any host.\n    Remove it and its .pub file?" "n"; then
        rm -f "${expanded_key_path}" "${expanded_key_path}.pub"
        printOkMsg "Removed key files."
    fi
}

# Removes a host entry from the SSH config file.
remove_ssh_host() {
    printBanner "Remove SSH Host"

    local host_to_remove="$1"
    if [[ -z "$host_to_remove" ]]; then
        host_to_remove=$(select_ssh_host "Select a host to remove:")
        [[ $? -ne 0 ]] && return
    fi

    if ! prompt_yes_no "Are you sure you want to remove '${host_to_remove}'?\n    This will permanently delete the host from your config." "n"; then
        printInfoMsg "Removal cancelled."
        return
    fi

    # Get the IdentityFile path *before* removing the host from the config.
    local identity_file_to_check
    identity_file_to_check=$(_get_explicit_ssh_config_value "$host_to_remove" "IdentityFile")

    # Get the config content without the specified host block
    local new_config_content
    new_config_content=$(_remove_host_block_from_config "$host_to_remove")

    # Overwrite the config file with the new content, squeezing blank lines
    echo "$new_config_content" | cat -s > "$SSH_CONFIG_PATH"

    printOkMsg "Host '${host_to_remove}' has been removed."

    # Pass the actual key file path to the cleanup function.
    _cleanup_orphaned_key "$identity_file_to_check"
}

# Exports selected SSH host configurations to a file.
export_ssh_hosts() {
    printBanner "Export SSH Hosts"

    mapfile -t hosts < <(get_ssh_hosts)
    if [[ ${#hosts[@]} -eq 0 ]]; then
        printInfoMsg "No hosts found to export."
        return
    fi

    # Get the detailed menu options to show more info to the user.
    local -a menu_options
    get_detailed_ssh_hosts_menu_options menu_options

    # The "All" option is a feature of interactive_multi_select_menu.
    local menu_output
    local header
    # The 5 spaces are to align the header with the menu items, which are prefixed by '❯ [ ] '.
    header=$(printf "     %-20s ${C_WHITE}%s${T_RESET}" "HOST ALIAS" "user@hostname[:port]")
    menu_output=$(interactive_multi_select_menu "Select hosts to export (space to toggle, enter to confirm):" "$header" "All" "${menu_options[@]}")
    if [[ $? -ne 0 ]]; then
        printInfoMsg "Export cancelled."
        return
    fi

    mapfile -t selected_indices < <(echo "$menu_output")

    if [[ ${#selected_indices[@]} -eq 0 ]]; then
        printInfoMsg "No hosts selected for export."
        return
    fi

    local -a hosts_to_export
    for index in "${selected_indices[@]}"; do
        # The menu options are "All", then hosts[0], hosts[1], ...
        # So index 1 from menu corresponds to hosts[0].
        if (( index > 0 )); then
            hosts_to_export+=("${hosts[index-1]}")
        fi
    done

    if [[ ${#hosts_to_export[@]} -eq 0 ]]; then
        printInfoMsg "No hosts selected for export."
        return
    fi

    local export_file
    prompt_for_input "Enter path for export file" export_file "ssh_hosts_export.conf"

    # Clear the file or create it
    true > "$export_file"

    printInfoMsg "Exporting ${#hosts_to_export[@]} host(s)..."
    for host in "${hosts_to_export[@]}"; do
        # Get the block for the host and append it to the export file
        echo "" >> "$export_file" # Add a newline for separation
        _get_host_block_from_config "$host" "$SSH_CONFIG_PATH" >> "$export_file"
    done

    # Clean up potential leading newline from the first entry
    sed -i '1{/^$/d;}' "$export_file"

    printOkMsg "Successfully exported ${#hosts_to_export[@]} host(s) to ${C_L_BLUE}${export_file}${T_RESET}."
}

# Imports SSH host configurations from a file.
import_ssh_hosts() {
    printBanner "Import SSH Hosts"

    local import_file
    prompt_for_input "Enter path of file to import from" import_file

    if [[ ! -f "$import_file" ]]; then
        printErrMsg "Import file not found: ${import_file}"
        return 1
    fi

    # Get hosts from the import file
    local -a hosts_to_import
    mapfile -t hosts_to_import < <(awk '/^[Hh]ost / && $2 != "*" {for (i=2; i<=NF; i++) print $i}' "$import_file")

    if [[ ${#hosts_to_import[@]} -eq 0 ]]; then
        printInfoMsg "No valid 'Host' entries found in ${import_file}."
        return
    fi

    printInfoMsg "Found ${#hosts_to_import[@]} host(s) to import: ${C_L_CYAN}${hosts_to_import[*]}${T_RESET}"

    local imported_count=0 overwritten_count=0 skipped_count=0

    for host in "${hosts_to_import[@]}"; do
        local should_add=false
        if grep -q -E "^\s*Host\s+${host}\s*$" "$SSH_CONFIG_PATH"; then
            prompt_yes_no "Host '${host}' already exists. Overwrite it?" "n"
            local choice=$?
            case $choice in
                0) # Yes
                    # Atomically replace the host block
                    local config_without_host; config_without_host=$(_remove_host_block_from_config "$host")
                    local new_block; new_block=$(_get_host_block_from_config "$host" "$import_file")
                    echo -e "${config_without_host}\n\n${new_block}" | cat -s > "$SSH_CONFIG_PATH"
                    ((overwritten_count++))
                    ;;
                1) # No
                    printInfoMsg "Skipping existing host '${host}'."; ((skipped_count++))
                    ;;
                2) # Cancel
                    printInfoMsg "Import operation cancelled by user."
                    # Break out of the for loop
                    break
                    ;;
            esac
        else
            # Host is new, so append it.
            echo "" >> "$SSH_CONFIG_PATH"; _get_host_block_from_config "$host" "$import_file" >> "$SSH_CONFIG_PATH"
            ((imported_count++))
        fi
    done

    local summary="Import complete. Added: ${imported_count}, Overwrote: ${overwritten_count}, Skipped: ${skipped_count}."
    printOkMsg "$summary"
}

# (Private) Helper to test connection to a specific host using BatchMode.
# Usage: _test_connection_for_host <host_alias>
_test_connection_for_host() {
    local host_to_test="$1"
    # -o BatchMode=yes: Never ask for passwords.
    # -o ConnectTimeout=5: A shorter timeout is better for quick tests.
    # 'exit' is a simple command that immediately closes the connection upon success.
    if run_with_spinner "Testing connection to '${host_to_test}'..." \
        ssh -o BatchMode=yes -o ConnectTimeout=5 "${host_to_test}" 'exit'
    then
        # remove the spinner output to reduce visual clutter
        clear_lines_up 1
        printOkMsg "Connection to '${host_to_test}' was ${BG_GREEN}${C_BLACK} successful ${T_RESET}"
        return 0
    else
        # run_with_spinner prints the error details from ssh
        printInfoMsg "Check your SSH config, network, firewall rules, and ensure your public key is on the server."
        return 1
    fi
}

# Tests the SSH connection to a selected server.
test_ssh_connection() {
    printBanner "Test SSH Connection"

    local host_to_test
    host_to_test=$(select_ssh_host "Select a host to test:")
    [[ $? -ne 0 ]] && return

    _test_connection_for_host "$host_to_test"
}

# (Private) The actual test logic for a single host, run in the background.
# It writes its result to a file in a temporary directory.
# Usage: _test_single_host_in_background <host> <result_dir>
_test_single_host_in_background() {
    local host_to_test="$1"
    local result_dir="$2"
    # The result file is named after the host, with slashes replaced to be safe.
    local result_file="${result_dir}/${host_to_test//\//_}"
 
    # Run ssh only ONCE, capturing stderr and checking the exit code.
    # This is much faster for failed connections than running it twice.
    # A shorter timeout (5s) is used to speed up the "all hosts" test.
    local error_output
    if error_output=$(ssh -o BatchMode=yes -o ConnectTimeout=5 "${host_to_test}" 'exit' 2>&1); then
        echo "success" > "$result_file"
    else
        # If the command failed but produced no output (e.g., timeout), provide a generic message.
        if [[ -z "$error_output" ]]; then
            echo "Connection timed out or failed without error message." > "$result_file"
        else
            echo "$error_output" > "$result_file"
        fi
    fi
}

# Tests all configured SSH hosts in parallel.
test_all_ssh_connections() {
    printBanner "Test All SSH Connections"

    mapfile -t hosts < <(get_ssh_hosts)
    if [[ ${#hosts[@]} -eq 0 ]]; then
        printInfoMsg "No hosts found in your SSH config file to test."
        return
    fi

    local result_dir
    result_dir=$(mktemp -d)
    # Ensure temp directory is cleaned up on exit or interrupt.
    trap 'rm -rf "$result_dir"' RETURN INT TERM

    local -a pids
    printInfoMsg "Starting tests for ${#hosts[@]} hosts in parallel..."
    for host in "${hosts[@]}"; do
        # Run the test for each host in the background.
        _test_single_host_in_background "$host" "$result_dir" &
        pids+=($!)
    done

    # Wait for all background jobs to complete, with a spinner.
    wait_for_pids_with_spinner "Running all connection tests" "${pids[@]}"

    # --- Print Summary ---
    printMsg "\n${T_ULINE}Test Results:${T_RESET}"
    local success_count=0
    local failure_count=0

    for host in "${hosts[@]}"; do
        local result_file="${result_dir}/${host//\//_}"
        local result
        result=$(<"$result_file")

        if [[ "$result" == "success" ]]; then
            ((success_count++))
            printOkMsg "Connection to '${host}' was ${BG_GREEN}${C_BLACK} successful ${T_RESET}"
        else
            ((failure_count++))
            printErrMsg "${host}"
            # Indent the error message for readability.
            while IFS= read -r line; do
                printMsg "    ${C_GRAY}${line}${T_RESET}"
            done <<< "$result"
        fi
    done

    # Final summary line
    echo
    local summary_msg
    if (( failure_count > 0 )); then
        summary_msg="Summary: ${C_L_GREEN}${success_count} successful${T_RESET}, ${C_L_RED}${failure_count} failed${T_RESET}."
        printErrMsg "$summary_msg"
    else
        summary_msg="Summary: ${C_L_GREEN}${success_count} successful${T_RESET}, ${C_GRAY}${failure_count} failed${T_RESET}."
        printOkMsg "$summary_msg"
    fi
}

# (Private) Reads saved port forwards from the config file.
# Populates arrays with their details.
# Usage: _get_saved_port_forwards types_array specs_array hosts_array descs_array
_get_saved_port_forwards() {
    local -n out_types="$1" out_specs="$2" out_hosts="$3" out_descs="$4"
    out_types=() out_specs=() out_hosts=() out_descs=()
    if [[ ! -f "$PORT_FORWARDS_CONFIG_PATH" ]]; then return 1; fi
    while IFS='|' read -r type spec host desc || [[ -n "$type" ]]; do
        [[ -z "$type" || "$type" =~ ^# ]] && continue
        out_types+=("$type"); out_specs+=("$spec"); out_hosts+=("$host"); out_descs+=("$desc")
    done < "$PORT_FORWARDS_CONFIG_PATH"
}

# (Private) Writes an array of port forward configurations to the file, overwriting it.
# Usage: _save_all_port_forwards types_array specs_array hosts_array descs_array
_save_all_port_forwards() {
    # Use ref_ prefix for namerefs to avoid circular reference if caller uses same variable names.
    local -n ref_types="$1" ref_specs="$2" ref_hosts="$3" ref_descs="$4"
    local temp_file; temp_file=$(mktemp)
    for i in "${!ref_types[@]}"; do echo "${ref_types[i]}|${ref_specs[i]}|${ref_hosts[i]}|${ref_descs[i]}" >> "$temp_file"; done
    mv "$temp_file" "$PORT_FORWARDS_CONFIG_PATH"
}

# (Private) Prompts user for all details of a port forward. Used by add and edit.
# Usage: _prompt_for_port_forward_details type_var spec_var host_var desc_var [defaults...]
_prompt_for_port_forward_details() {
    local -n out_type="$1" out_spec="$2" out_host="$3" out_desc="$4"
    local d_type="${5:-}" d_spec_p1="${6:-}" d_spec_h="${7:-}" d_spec_p2="${8:-}" d_host="${9:-}" d_desc="${10:-}"
    local -a type_options=("Local (-L)" "Remote (-R)"); local type_idx; type_idx=$(interactive_single_select_menu "Select forward type:" "" "${type_options[@]}")
    [[ $? -ne 0 ]] && { printInfoMsg "Cancelled."; return 1; }
    if [[ "$type_idx" -eq 0 ]]; then out_type="Local"; else out_type="Remote"; fi
    out_host=$(select_ssh_host "Select a host for the port forward:" "false"); [[ $? -ne 0 ]] && return 1
    local p1_val p1_prompt h_val h_prompt p2_val p2_prompt
    if [[ "$out_type" == "Local" ]]; then
        p1_prompt="Enter the LOCAL port to listen on"; h_prompt="Enter the REMOTE host to connect to (from ${out_host})"; p2_prompt="Enter the REMOTE port to connect to"
    else
        p1_prompt="Enter the REMOTE port to listen on (on ${out_host})"; h_prompt="Enter the LOCAL host to connect to"; p2_prompt="Enter the LOCAL port to connect to"
    fi
    prompt_for_input "$p1_prompt" p1_val "${d_spec_p1:-8080}" || return 1
    prompt_for_input "$h_prompt" h_val "${d_spec_h:-localhost}" || return 1
    prompt_for_input "$p2_prompt" p2_val "${d_spec_p2:-80}" || return 1
    out_spec="${p1_val}:${h_val}:${p2_val}"
    prompt_for_input "Enter a short description for this forward" out_desc "${d_desc:-${out_spec} on ${out_host}}" || return 1
    return 0
}

# Adds a new port forward configuration to the saved list.
add_saved_port_forward() {
    printBanner "Add New Saved Port Forward"
    local -a types specs hosts descs; _get_saved_port_forwards types specs hosts descs
    local new_type new_spec new_host new_desc; if ! _prompt_for_port_forward_details new_type new_spec new_host new_desc; then return; fi
    types+=("$new_type"); specs+=("$new_spec"); hosts+=("$new_host"); descs+=("$new_desc")
    _save_all_port_forwards types specs hosts descs
    printOkMsg "Saved new port forward: ${new_desc}"
}

# (Private) A generic, reusable interactive loop for the port forward editors.
# This function encapsulates the shared UI loop for editing and cloning forwards.
#
# It modifies variables in the caller's scope via namerefs.
#
# Usage: _interactive_port_forward_editor_loop <banner> <p_type> <p_p1> <p_h> <p_p2> <p_host> <p_desc>
# Returns 0 if the user chooses to save, 1 if they cancel/quit.
_draw_interactive_port_forward_editor_ui() {
    local new_type="$1" new_p1="$2" new_h="$3" new_p2="$4" new_host="$5" new_desc="$6"
    local original_type="$7" original_p1="$8" original_h="$9" original_p2="${10}" original_host="${11}" original_desc="${12}"

    # Helper to format a line, adding a change indicator (*) if needed.
    _format_line() {
        local key="$1" label="$2" new_val="$3" original_val="$4"

        local display_val="${new_val}"
        if [[ -z "$display_val" ]]; then display_val="${C_GRAY}(not set)${T_RESET}"; else display_val="${C_L_CYAN}${display_val}${T_RESET}"; fi

        local change_indicator=" "
        if [[ "$new_val" != "$original_val" ]]; then change_indicator="${C_L_YELLOW}*${T_RESET}"; fi

        printf "  ${C_L_WHITE}%s)${T_RESET} %b %-15s: %b\n" "$key" "$change_indicator" "$label" "$display_val"
    }

    local p1_label="Local Port" h_label="Remote Host" p2_label="Remote Port"
    if [[ "$new_type" == "Remote" ]]; then
        p1_label="Remote Port" h_label="Local Host" p2_label="Local Port"
    fi

    printMsg "Choose an option to configure:"
    _format_line "1" "Type" "$new_type" "$original_type"
    _format_line "2" "SSH Host" "$new_host" "$original_host"
    _format_line "3" "${p1_label}" "$new_p1" "$original_p1"
    _format_line "4" "${h_label}" "$new_h" "$original_h"
    _format_line "5" "${p2_label}" "$new_p2" "$original_p2"
    _format_line "6" "Description" "$new_desc" "$original_desc"

    echo
    printMsg "  ${C_L_WHITE}c) ${C_L_YELLOW}(C)ancel/(D)iscard${T_RESET} all pending changes"
    printMsg "  ${C_L_WHITE}s) ${C_L_GREEN}(S)ave${T_RESET} and Quit"
    printMsg "  ${C_L_WHITE}q) ${C_L_YELLOW}(Q)uit${T_RESET} without saving (or press ${C_L_YELLOW}ESC${T_RESET})"
    echo
    printMsgNoNewline "${T_QST_ICON} Your choice: "
}

_interactive_port_forward_editor_loop() {
    local mode="$1"
    local banner_text="$2"
    # These are the *names* of the variables in the caller's scope.
    local p_type="$3" p_p1="$4" p_h="$5" p_p2="$6" p_host="$7" p_desc="$8"
    # Use namerefs internally for easier access to the values.
    local -n n_type="$p_type" n_p1="$p_p1" n_h="$p_h" n_p2="$p_p2" n_host="$p_host" n_desc="$p_desc"
    # Original values are passed by value for comparison.
    local original_type="$9" original_p1="${10}" original_h="${11}" original_p2="${12}" original_host="${13}" original_desc="${14}"

    while true; do
        clear; printBanner "$banner_text"
        _draw_interactive_port_forward_editor_ui "$n_type" "$n_p1" "$n_h" "$n_p2" "$n_host" "$n_desc" \
                                                 "$original_type" "$original_p1" "$original_h" "$original_p2" "$original_host" "$original_desc"

        local key; key=$(read_single_char)
        case "$key" in
            '1')
                # Edit Type
                clear_current_line
                local -a type_options=("Local (-L)" "Remote (-R)"); local type_idx
                type_idx=$(interactive_single_select_menu "Select forward type:" "" "${type_options[@]}")
                if [[ $? -eq 0 ]]; then if [[ "$type_idx" -eq 0 ]]; then n_type="Local"; else n_type="Remote"; fi; fi ;;
            '2')
                # Edit SSH Host
                clear_current_line
                local selected_host; selected_host=$(select_ssh_host "Select a new SSH host:" "false")
                if [[ $? -eq 0 ]]; then n_host="$selected_host"; fi ;;
            '3')
                # Edit Port 1
                clear_current_line
                local p1_label="Local Port"; if [[ "$n_type" == "Remote" ]]; then p1_label="Remote Port"; fi
                prompt_for_input "Enter the ${p1_label} to listen on" "$p_p1" "$n_p1" ;;
            '4')
                # Edit Host
                clear_current_line
                local h_prompt="Enter the REMOTE host to connect to (from ${n_host})"; if [[ "$n_type" == "Remote" ]]; then h_prompt="Enter the LOCAL host to connect to"; fi
                prompt_for_input "$h_prompt" "$p_h" "$n_h" ;;
            '5')
                # Edit Port 2
                clear_current_line
                local p2_prompt="Enter the REMOTE port to connect to"; if [[ "$n_type" == "Remote" ]]; then p2_prompt="Enter the LOCAL port to connect to"; fi
                prompt_for_input "$p2_prompt" "$p_p2" "$n_p2" ;;
            '6')
                # Edit Description
                prompt_for_input "Enter a short description" "$p_desc" "$n_desc" ;;
            'c'|'C'|'d'|'D')
                # Discard
                clear_current_line
                local question="Discard all pending changes?"; if [[ "$mode" == "clone" ]]; then question="Discard all changes and reset fields?"; fi
                if prompt_yes_no "$question" "y"; then
                    n_type="$original_type"; n_p1="$original_p1"; n_h="$original_h"; n_p2="$original_p2"; n_host="$original_host"; n_desc="$original_desc"
                    printInfoMsg "Changes discarded."; sleep 1
                fi ;;
            's'|'S') return 0 ;; # Signal to Save
            'q'|'Q'|"$KEY_ESC")
                # Quit
                clear_current_line
                if [[ "$n_type" != "$original_type" || "$n_p1" != "$original_p1" || "$n_h" != "$original_h" || "$n_p2" != "$original_p2" || "$n_host" != "$original_host" || "$n_desc" != "$original_desc" ]]; then
                    clear_current_line
                    if prompt_yes_no "You have unsaved changes. Quit without saving?" "n"; then printInfoMsg "Operation cancelled."; sleep 1; return 1; fi
                else return 1; fi ;;
        esac
    done
}

# Edits a saved port forward configuration.
edit_saved_port_forward() {
    local idx_to_edit="$1"
    local -a all_types all_specs all_hosts all_descs; _get_saved_port_forwards all_types all_specs all_hosts all_descs
    local original_type="${all_types[$idx_to_edit]}" original_spec="${all_specs[$idx_to_edit]}" original_host="${all_hosts[$idx_to_edit]}" original_desc="${all_descs[$idx_to_edit]}"

    # Deconstruct spec for editing
    local original_p1="${original_spec%%:*}"; local remote_part="${original_spec#*:}"
    local original_h="${remote_part%:*}"; local original_p2="${remote_part##*:}"

    # Set up variables for the editor loop
    local new_type="$original_type" new_host="$original_host" new_desc="$original_desc"
    local new_p1="$original_p1" new_h="$original_h" new_p2="$original_p2"

    local banner_text="Edit Saved Port Forward - ${C_L_CYAN}${original_desc}${C_BLUE}"
    if ! _interactive_port_forward_editor_loop "edit" "$banner_text" \
        new_type new_p1 new_h new_p2 new_host new_desc \
        "$original_type" "$original_p1" "$original_h" "$original_p2" "$original_host" "$original_desc"; then
        printInfoMsg "Edit cancelled. No changes were saved."
        return
    fi

    local new_spec="${new_p1}:${new_h}:${new_p2}"
    if [[ "$new_type" == "$original_type" && "$new_spec" == "$original_spec" && "$new_host" == "$original_host" && "$new_desc" == "$original_desc" ]]; then
        printInfoMsg "No changes detected. Configuration remains unchanged."
        return
    fi

    all_types[$idx_to_edit]="$new_type"
    all_specs[$idx_to_edit]="$new_spec"
    all_hosts[$idx_to_edit]="$new_host"
    all_descs[$idx_to_edit]="$new_desc"
    _save_all_port_forwards all_types all_specs all_hosts all_descs
    printOkMsg "Saved port forward has been updated."
}

# Deletes a saved port forward configuration.
delete_saved_port_forward() {
    local idx_to_delete="$1" type="$2" spec="$3" host="$4"
    if ! prompt_yes_no "Permanently delete saved forward '${spec}' on '${host}'?" "n"; then printInfoMsg "Deletion cancelled."; return; fi
    local -a all_types all_specs all_hosts all_descs; _get_saved_port_forwards all_types all_specs all_hosts all_descs
    local -a new_types new_specs new_hosts new_descs
    for i in "${!all_types[@]}"; do
        if [[ "$i" -ne "$idx_to_delete" ]]; then
            new_types+=("${all_types[i]}"); new_specs+=("${all_specs[i]}"); new_hosts+=("${all_hosts[i]}"); new_descs+=("${all_descs[i]}")
        fi
    done
    _save_all_port_forwards new_types new_specs new_hosts new_descs
    printOkMsg "Deleted saved port forward."
}

# Clones a saved port forward configuration.
clone_saved_port_forward() {
    local type_to_clone="$1" spec_to_clone="$2" host_to_clone="$3" desc_to_clone="$4"

    # Deconstruct spec for editing
    local original_p1="${spec_to_clone%%:*}"; local remote_part="${spec_to_clone#*:}"
    local original_h="${remote_part%:*}"; local original_p2="${remote_part##*:}"

    # Set up initial values for the new cloned forward
    local new_type="$type_to_clone" new_host="$host_to_clone" new_desc="Clone of ${desc_to_clone}"
    local new_p1=$((original_p1 + 1)) new_h="$original_h" new_p2="$original_p2"

    local banner_text="Clone Saved Port Forward - from ${C_L_CYAN}${desc_to_clone}${C_BLUE}"
    if ! _interactive_port_forward_editor_loop "clone" "$banner_text" \
        new_type new_p1 new_h new_p2 new_host new_desc \
        "$type_to_clone" "$original_p1" "$original_h" "$original_p2" "$host_to_clone" "$desc_to_clone"; then
        printInfoMsg "Clone cancelled. No changes were saved."
        return
    fi

    local new_spec="${new_p1}:${new_h}:${new_p2}"
    local -a all_types all_specs all_hosts all_descs; _get_saved_port_forwards all_types all_specs all_hosts all_descs
    all_types+=("$new_type"); all_specs+=("$new_spec"); all_hosts+=("$new_host"); all_descs+=("$new_desc")
    _save_all_port_forwards all_types all_specs all_hosts all_descs
    printOkMsg "Saved cloned port forward."
}

# Activates a saved port forward by running ssh in the background.
activate_port_forward() {
    local type="$1" spec="$2" host="$3"
    local flag; if [[ "$type" == "Local" ]]; then flag="-L"; else flag="-R"; fi
    local -a cmd_array=("ssh" "-o" "ExitOnForwardFailure=yes" "-N" "-f" "${flag}" "${spec}" "${host}")
    printInfoMsg "Activating forward: ${type} ${spec} on ${host}"
    printMsg "  ${C_L_BLUE}${cmd_array[*]}${T_RESET}"
    if run_with_spinner "Establishing port forward..." "${cmd_array[@]}"; then
        printOkMsg "Port forward activated in the background."
    else
        printErrMsg "Failed to activate port forward."
    fi
}

# Deactivates a port forward by killing its process.
deactivate_port_forward() {
    local pid="$1" spec="$2" host="$3"
    if ! prompt_yes_no "Stop port forward ${spec} on ${host} (PID: ${pid})?" "y"; then printInfoMsg "Operation cancelled."; return; fi
    if run_with_spinner "Stopping port forward (PID: ${pid})..." kill "$pid"; then
        printOkMsg "Port forward stopped."
    else
        printErrMsg "Failed to stop port forward process."
    fi
}

# (Private) Formats a line for displaying port forward information with colors.
# Usage: _format_port_forward_line <pid> <type> <spec> <host>
_format_port_forward_line() {
    local pid="$1"
    local type="$2"
    local spec="$3"
    local host="$4"

    local type_color=""
    if [[ "$type" == "Local" ]]; then
        type_color="$C_L_CYAN"
    elif [[ "$type" == "Remote" ]]; then
        type_color="$C_L_YELLOW"
    fi

    # PID is default, Type is colored, Spec is white, Host is cyan.
    printf "%-10s ${type_color}%-8s ${C_L_WHITE}%-30s ${C_L_CYAN}%s" \
        "$pid" \
        "$type" \
        "$spec" \
        "$host"
}
# (Private) Finds active port forwards and populates arrays with their details.
# Usage: _get_active_port_forwards pids_array types_array specs_array hosts_array
# Returns 0 if forwards are found, 1 otherwise.
_get_active_port_forwards() {
    local -n out_pids="$1"
    local -n out_types="$2"
    local -n out_specs="$3"
    local -n out_hosts="$4"

    # Clear output arrays
    out_pids=()
    out_types=()
    out_specs=()
    out_hosts=()

    local active_forwards
    # Use awk to find processes that are ssh and contain all the necessary flags for a backgrounded port forward.
    # This is more robust than a simple grep, as it is not dependent on the order of arguments (e.g., -o).
    # It looks for 'ssh', '-N', '-f', and either '-L' or '-R'.
    active_forwards=$(ps -eo pid,command | awk '/[s]sh/ && /-N/ && /-f/ && /-[LR]/')

    if [[ -z "$active_forwards" ]]; then
        return 1 # No forwards found
    fi

    while IFS= read -r line; do
        line=$(echo "$line" | sed 's/^[[:space:]]*//')
        local pid; pid=$(echo "$line" | cut -d' ' -f1)
        local cmd; cmd=$(echo "$line" | cut -d' ' -f2-)
        local type_flag current_spec current_host
        local -a parts=($cmd)
        for i in "${!parts[@]}"; do
            if [[ "${parts[$i]}" == "-L" || "${parts[$i]}" == "-R" ]]; then
                type_flag="${parts[$i]}"; current_spec="${parts[$i+1]}"; break
            fi
        done
        current_host="${parts[-1]}"
        local type_str="Unknown"
        [[ "$type_flag" == "-L" ]] && type_str="Local"
        [[ "$type_flag" == "-R" ]] && type_str="Remote"

        out_pids+=("$pid")
        out_types+=("$type_str")
        out_specs+=("$current_spec")
        out_hosts+=("$current_host")
    done <<< "$active_forwards"

    return 0
}

# Lists all active SSH port forwards found by the script.
list_active_port_forwards() {
    printBanner "Active Port Forwards"

    local -a pids types specs hosts
    if ! _get_active_port_forwards pids types specs hosts; then
        printInfoMsg "No active SSH port forwards started by this script were found."
        return
    fi

    local header; header=$(printf "%-10s %-8s %-30s %s" "PID" "TYPE" "FORWARD" "HOST")
    printMsg "  ${C_WHITE}${header}${T_RESET}"

    for i in "${!pids[@]}"; do
        printMsg "  $(_format_port_forward_line "${pids[i]}" "${types[i]}" "${specs[i]}" "${hosts[i]}")${T_RESET}"
    done

    # empty line for spacing
    printMsg ""
}

# Lists all configured SSH hosts with details.
list_all_hosts() {
    printBanner "List All Configured Hosts"

    local -a menu_options
    # Get detailed host list, including key info.
    get_detailed_ssh_hosts_menu_options menu_options "true"

    if [[ ${#menu_options[@]} -eq 0 ]]; then
        printInfoMsg "No hosts found in your SSH config file."
        return
    fi

    local header
    header=$(printf "%-20s %s" "HOST ALIAS" "user@hostname[:port] (key)")
    printMsg "${C_WHITE}${header}${T_RESET}"
    printMsg "${C_GRAY}${DIV}${T_RESET}"

    for option in "${menu_options[@]}"; do
        # The menu options are already formatted with colors.
        printMsg "${option}"
    done

    # add space
    printMsg ""
}

# --- Port Forwarding View Helpers ---

# (Private) Formats a line for displaying a saved port forward.
# Usage: _format_saved_port_forward_line <status> <pid> <type> <spec> <host> <desc>
_format_saved_port_forward_line() {
    local status="$1" pid="$2" type="$3" spec="$4" host="$5" desc="$6"
    local type_color=""
    if [[ "$type" == "Local" ]]; then type_color="$C_L_CYAN"; elif [[ "$type" == "Remote" ]]; then type_color="$C_L_YELLOW"; fi
    local status_icon
    if [[ "$status" == "active" ]]; then status_icon="${C_L_GREEN}[✓]"; else status_icon="${C_GRAY}[-]"; fi

    local line1 line2
    line1=$(printf "%-3s %-8s ${type_color}%-8s ${C_L_WHITE}%-45s" \
        "$status_icon" "$pid" "$type" "$spec")

    # The extra 3 spaces at the start are to align with the '❯ ' prefix from the list view.
    line2=$(printf "   ${C_L_CYAN} %-20s ${C_L_WHITE}%-45s" \
        "$host" "$desc")

    printf "%s\n%s${T_RESET}" "$line1" "$line2"
}

_port_forward_view_draw_header() {
    local header1 header2
    header1=$(printf "   %-3s %-8s %-8s %-45s" "[ ]" "PID" "TYPE" "FORWARD")
    # Indent line 2 to align HOST under TYPE. 10+1+8+1=20 spaces for first 2 columns + separators
    header2=$(printf "    %-20s %-45s" "HOST" "DESCRIPTION")
    printMsg "${C_WHITE}${header1}${T_RESET}"
    printMsg "${C_WHITE}${header2}${T_RESET}"
}

_port_forward_view_draw_footer() {
    printMsg "  ${T_BOLD}Navigation:${T_RESET}   ${C_L_CYAN}↓/↑/j/k${T_RESET} Move | ${C_L_YELLOW}Q/ESC${T_RESET} Back"
    printMsg "  ${T_BOLD}Actions:${T_RESET}      ${C_L_GREEN}(A)dd${T_RESET} | (${C_L_RED}D${T_RESET})elete | (${C_L_CYAN}E${T_RESET})dit | (${C_L_CYAN}C${T_RESET})lone | ${C_L_GREEN}ENTER${T_RESET} Start/Stop"
}

_port_forward_view_refresh() {
    local -n out_menu_options="$1" out_data_payloads="$2"; out_menu_options=(); out_data_payloads=()
    local -a saved_types saved_specs saved_hosts saved_descs; _get_saved_port_forwards saved_types saved_specs saved_hosts saved_descs
    local -a active_pids active_types active_specs active_hosts; _get_active_port_forwards active_pids active_types active_specs active_hosts
    local -A active_map
    for i in "${!active_pids[@]}"; do
        local key="${active_types[i]}|${active_specs[i]}|${active_hosts[i]}"; active_map["$key"]="${active_pids[i]}"
    done
    for i in "${!saved_types[@]}"; do
        local type="${saved_types[i]}" spec="${saved_specs[i]}" host="${saved_hosts[i]}" desc="${saved_descs[i]}"
        local key="${type}|${spec}|${host}"
        local status status_pid
        if [[ -n "${active_map[$key]}" ]]; then status="active"; status_pid="${active_map[$key]}"; else status="inactive"; status_pid=""; fi
        out_menu_options+=("$(_format_saved_port_forward_line "$status" "$status_pid" "$type" "$spec" "$host" "$desc")")
        out_data_payloads+=("$i|$type|$spec|$host|$desc|$status_pid")
    done
}

_port_forward_view_key_handler() {
    local key="$1"
    local selected_payload="$2"
    # local selected_index="$3" # Unused
    local -n out_result="$4"
    out_result=0 # Default to no-op
    local idx type spec host desc pid
    if [[ -n "$selected_payload" ]]; then IFS='|' read -r idx type spec host desc pid <<< "$selected_payload"; fi
    case "$key" in
        'a'|'A') run_menu_action "add_saved_port_forward"; out_result=1 ;;
        'e'|'E') if [[ -n "$selected_payload" ]]; then run_menu_action "edit_saved_port_forward" "$idx"; out_result=1; fi ;;
        'd'|'D') if [[ -n "$selected_payload" ]]; then run_menu_action "delete_saved_port_forward" "$idx" "$type" "$spec" "$host"; out_result=1; fi ;;
        'c'|'C') if [[ -n "$selected_payload" ]]; then run_menu_action "clone_saved_port_forward" "$type" "$spec" "$host" "$desc"; out_result=1; fi ;;
        "$KEY_ENTER")
            if [[ -n "$selected_payload" ]]; then
                if [[ -n "$pid" ]]; then run_menu_action "deactivate_port_forward" "$pid" "$spec" "$host"; else run_menu_action "activate_port_forward" "$type" "$spec" "$host"; fi
                out_result=1
            fi ;;
        "$KEY_ESC"|"q"|"Q") out_result=2 ;; # Exit view
    esac
}

interactive_port_forward_view() {
    _interactive_list_view \
        "Active Port Forwards" \
        "_port_forward_view_draw_header" \
        "_port_forward_view_refresh" \
        "_port_forward_view_key_handler" \
        "_port_forward_view_draw_footer"
}

# Backs up the SSH config file to a timestamped file.
backup_ssh_config() {
    printBanner "Backup SSH Config"

    local backup_dir="${SSH_DIR}/backups"
    mkdir -p "$backup_dir"

    local timestamp
    timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
    local backup_file="${backup_dir}/config_${timestamp}.bak"

    if run_with_spinner "Creating backup of ${SSH_CONFIG_PATH}..." \
        cp "$SSH_CONFIG_PATH" "$backup_file"
    then
        # The spinner already prints a success message. We can add more detail.
        printInfoMsg "Backup saved to: ${C_L_BLUE}${backup_file}${T_RESET}"
    else
        # The spinner will print the error from `cp`.
        printErrMsg "Failed to create backup."
    fi
}

# (Private) A wrapper for running a menu action.
# It clears the screen, runs the function, and then prompts to continue.
run_menu_action() {
    local action_func="$1"
    shift
    clear

    # Show the cursor. Many actions launched from cursor-less views (like the
    # server list) require user input and thus need a visible cursor.
    printMsgNoNewline "${T_CURSOR_SHOW}" >/dev/tty

    # Call the function with any remaining arguments. It's expected to print its own banner.
    "$action_func" "$@"

    # Hide the cursor again before returning to the parent view, which expects
    # the cursor to be hidden. This is done before prompt_to_continue, which
    # does not require a visible cursor.
    printMsgNoNewline "${T_CURSOR_HIDE}" >/dev/tty

    # After the action is complete, wait for user input before returning to the menu.
    prompt_to_continue
}

# (Private) Generic function to display and handle a submenu loop.
# It takes a banner title, an array of ordered options, and a map of options to actions.
# Usage: _run_submenu <banner_title> "Option 1" "action1" "Option 2" "action2" ...
_run_submenu() {
    local banner_title="$1"
    shift
    local -a menu_definition=("$@")

    local -a ordered_options
    local -A actions_map

    for ((i=0; i<${#menu_definition[@]}; i+=2)); do
        ordered_options+=("${menu_definition[i]}")
        actions_map["${menu_definition[i]}"]="${menu_definition[i+1]}"
    done

    # Add the 'Back' option to the list for display
    local -a menu_options=("${ordered_options[@]}" "Back to main menu")

    while true; do
        clear
        printBanner "$banner_title"

        local selected_index
        selected_index=$(interactive_single_select_menu "Select an action:" "" "${menu_options[@]}")
        [[ $? -ne 0 ]] && break # ESC/q from menu returns to the previous menu

        local selected_option="${menu_options[$selected_index]}"

        if [[ "$selected_option" == "Back to main menu" ]]; then
            break
        fi

        # Get the action from the map.
        local action="${actions_map[$selected_option]}"

        # Handle special actions identified by a "SPECIAL_" prefix.
        if [[ "$action" == "SPECIAL_CONNECT" ]]; then
            clear
            printBanner "Connect to a server"
            local selected_host
            selected_host=$(select_ssh_host "Select a host to connect to:")
            if [[ $? -eq 0 ]]; then
                # Replace the script process with the ssh client.
                exec ssh "$selected_host"
            fi
            # If connection is cancelled, the loop continues.
        elif [[ "$action" == "SPECIAL_EDIT_CONFIG" ]]; then
            local editor="${EDITOR:-nvim}"
            if ! command -v "${editor}" &>/dev/null; then
                printErrMsg "Editor '${editor}' not found. Please set the EDITOR environment variable."
                prompt_to_continue
            else
                "${editor}" "${SSH_CONFIG_PATH}"
            fi
        else
            # This is the standard case: a function name to be passed to run_menu_action.
            if [[ -n "$action" ]]; then
                run_menu_action "$action"
            else
                printErrMsg "Internal error: No action defined for '${selected_option}'."
                prompt_to_continue
            fi
        fi
    done
}

# --- Server Management View Helpers ---

_server_view_draw_header() {
    local header; header=$(printf "   %-20s ${C_WHITE}%s${T_RESET}" "HOST ALIAS" "user@hostname[:port] (key)")
    printMsg "${C_WHITE}${header}${T_RESET}"
}

_server_view_draw_footer() {
    printMsg "  ${T_BOLD}Navigation:${T_RESET}   ${C_L_CYAN}↓/↑/j/k${T_RESET} Move | ${C_L_YELLOW}Q/ESC${T_RESET} Back"
    printMsg "  ${T_BOLD}Host Actions:${T_RESET} ${C_L_GREEN}(A)dd${T_RESET} | ${C_L_RED}(D)elete${T_RESET} | (${C_L_CYAN}C${T_RESET})lone"
    printMsg "  ${T_BOLD}Host Edit:${T_RESET}    (${C_L_CYAN}e${T_RESET})dit - wizard | (${C_L_CYAN}E${T_RESET})dit - advanced"
    printMsg "  ${T_BOLD}Connection:${T_RESET}   ${C_L_YELLOW}ENTER${T_RESET} Connect | (${C_L_CYAN}t${T_RESET})est selected | (${C_L_CYAN}T${T_RESET})est all"
}

_server_view_refresh() {
    local -n out_menu_options="$1"
    local -n out_data_payloads="$2"
    # Get raw host names for the data payload
    mapfile -t out_data_payloads < <(get_ssh_hosts)
    # Get formatted strings for display
    get_detailed_ssh_hosts_menu_options out_menu_options "true"
}

_server_view_key_handler() {
    local key="$1"
    local selected_host="$2"
    # local selected_index="$3" # Available but not needed for this view
    local -n out_result="$4"

    out_result=0 # Default to no-op
    case "$key" in
        "$KEY_ENTER")
            if [[ -n "$selected_host" ]] && prompt_yes_no "Connect to '${selected_host}'?" "y"; then
                clear; exec ssh "$selected_host"
            fi ;;
        'a'|'A') run_menu_action "add_ssh_host"; out_result=1 ;;
        'e') if [[ -n "$selected_host" ]]; then run_menu_action "edit_ssh_host" "$selected_host"; out_result=1; fi ;;
        'E') if [[ -n "$selected_host" ]]; then run_menu_action "edit_ssh_host_in_editor" "$selected_host"; out_result=1; fi ;;
        'd'|'D') if [[ -n "$selected_host" ]]; then run_menu_action "remove_ssh_host" "$selected_host"; out_result=1; fi ;;
        'c'|'C') if [[ -n "$selected_host" ]]; then run_menu_action "clone_ssh_host" "$selected_host"; out_result=1; fi ;;
        't') if [[ -n "$selected_host" ]]; then clear; printBanner "Test SSH Connection"; _test_connection_for_host "$selected_host"; prompt_to_continue; fi ;;
        'T') run_menu_action "test_all_ssh_connections" ;;
        "$KEY_ESC"|"q"|"Q") out_result=2 ;; # Exit view
    esac
}

interactive_server_management_view() {
    _interactive_list_view \
        "Server/Host Management" \
        "_server_view_draw_header" \
        "_server_view_refresh" \
        "_server_view_key_handler" \
        "_server_view_draw_footer"
}

--- Key Management View Helpers ---

_key_view_draw_header() {
    local header; header=$(printf " %-25s %-10s %-6s %s" "KEY FILENAME" "TYPE" "BITS" "COMMENT")
    printMsg "  ${C_WHITE}${header}${T_RESET}"
}

_key_view_draw_footer() {
    printMsg "  ${T_BOLD}Navigation:${T_RESET}   ${C_L_CYAN}↓/↑/j/k${T_RESET} Move | ${C_L_YELLOW}Q/ESC${T_RESET} Back"
    printMsg "  ${T_BOLD}Key Actions:${T_RESET}  (${C_L_GREEN}G${T_RESET})enerate | (${C_L_RED}D${T_RESET})elete | (${C_L_CYAN}R${T_RESET})ename"
    printMsg "                (${C_L_CYAN}V${T_RESET})iew public | (${C_L_CYAN}C${T_RESET})opy | Re-gen (${C_L_CYAN}P${T_RESET})ublic"
}

# (Private) Verifies a file is a valid private key and extracts its details.
_get_key_details() {
    local key_file="$1"
    local details
    # Heuristic: A file whose first line looks like a public key is not a private key.
    if head -n 1 "$key_file" 2>/dev/null | grep -q -E '^(ssh-(rsa|dss|ed25519)|ecdsa-sha2-nistp(256|384|521)) '; then return 1; fi
    # Attempt to get the key fingerprint. If this fails, it's not a valid key file.
    details=$(ssh-keygen -l -f "$key_file" 2>/dev/null)
    if [[ -z "$details" || $(echo "$details" | wc -l) -ne 1 ]]; then return 1; fi
    local bits; bits=$(echo "$details" | awk '{print $1}')
    local type; type=$(echo "$details" | awk '{print $NF}' | tr -d '()')
    local comment; comment=$(echo "$details" | awk '{for(i=3;i<NF;i++) printf "%s ",$i}' | sed 's/ $//')
    [[ -z "$comment" ]] && comment="(no comment)"
    echo "$type $bits $comment"
}

_key_view_refresh() {
    local -n out_menu_options="$1"
    local -n out_data_payloads="$2"
    out_data_payloads=()
    out_menu_options=()
    # Find all files in SSH_DIR that do NOT end in .pub, then verify they are valid private keys.
    while IFS= read -r key_path; do
        local details_str
        if details_str=$(_get_key_details "$key_path"); then
            out_data_payloads+=("$key_path")
            local filename; filename=$(basename "$key_path")
            local key_type key_bits key_comment
            read -r key_type key_bits key_comment <<< "$details_str"
            local formatted_string
            formatted_string=$(printf "%-25s %-10s %-6s %s" "${filename}" "${key_type}" "${key_bits}" "${key_comment}")
            out_menu_options+=("$formatted_string")
        fi
    done < <(find "$SSH_DIR" -maxdepth 1 -type f ! -name "*.pub")
}

_key_view_key_handler() {
    local key="$1"
    local selected_key_path="$2"
    # local selected_index="$3" # Unused
    local -n out_result="$4"

    out_result=0 # Default to no-op
    case "$key" in
        'g'|'G')
            run_menu_action "generate_ssh_key"; out_result=1 ;;
        'c'|'C')
            if [[ -n "$selected_key_path" ]]; then
                if [[ -f "${selected_key_path}.pub" ]]; then run_menu_action "copy_selected_ssh_key" "${selected_key_path}.pub";
                else printErrMsg "Public key for '${selected_key_path}' not found."; prompt_to_continue; fi
            fi ;;
        'd'|'D')
            if [[ -n "$selected_key_path" ]]; then run_menu_action "delete_ssh_key" "$selected_key_path"; out_result=1; fi ;;
        'r'|'R')
            if [[ -n "$selected_key_path" ]]; then run_menu_action "rename_ssh_key" "$selected_key_path"; out_result=1; fi ;;
        'v'|'V')
            if [[ -n "$selected_key_path" ]]; then
                if [[ -f "${selected_key_path}.pub" ]]; then run_menu_action "view_public_key" "${selected_key_path}.pub";
                else printErrMsg "Public key for '${selected_key_path}' not found."; prompt_to_continue; fi
            fi ;;
        'p'|'P')
            if [[ -n "$selected_key_path" ]]; then run_menu_action "regenerate_public_key" "$selected_key_path"; fi ;;
        "$KEY_ESC"|"q"|"Q")
            out_result=2 ;; # Exit view
    esac
}

interactive_key_management_view() {
    _interactive_list_view \
        "Key Management" \
        "_key_view_draw_header" \
        "_key_view_refresh" \
        "_key_view_key_handler" \
        "_key_view_draw_footer"
}

key_menu() {
    local -a menu_definition=(
        "Copy an SSH key to a server" "copy_ssh_id"
        "Generate a new SSH key"      "generate_ssh_key"
    )
    _run_submenu "Key Management" "${menu_definition[@]}"
}

advanced_menu() {
    local -a menu_definition=(
        "Open SSH config in editor"      "SPECIAL_EDIT_CONFIG"
        "Edit host block in editor"      "edit_ssh_host_in_editor"
        "Reorder hosts in config file"   "reorder_ssh_hosts"
        "Backup SSH config"              "backup_ssh_config"
        "Export hosts to a file"         "export_ssh_hosts"
        "Import hosts from a file"       "import_ssh_hosts"
    )
    _run_submenu "Advanced Tools" "${menu_definition[@]}"
}

# Bypasses the main menu and goes directly to the host selection for a direct connection.
direct_connect() {
    local selected_host
    selected_host=$(select_ssh_host "Select a host to connect to:")
    if [[ $? -eq 0 ]]; then
        # Replace the script process with the ssh client.
        exec ssh "$selected_host"
    fi
    # If selection is cancelled, the script will just exit.
    # select_ssh_host prints a cancellation message, so we exit with a non-zero status
    # to indicate the requested action was not completed.
    exit 1
}

# Bypasses the main menu and goes directly to testing connections.
# Handles interactive selection, a specific host, or all hosts.
direct_test() {
    local target="$1"

    if [[ -z "$target" ]]; then
        # No target specified, run interactive selection.
        # This function already has a banner, so we just call it.
        test_ssh_connection
        return
    fi

    if [[ "$target" == "all" ]]; then
        # Target is 'all', test all connections.
        test_all_ssh_connections
        return
    fi

    # Target is a specific host. First, validate it exists.
    # Use grep with -F (fixed string) and -x (exact line match) for robust validation.
    if get_ssh_hosts | grep -qFx "$target"; then
        printBanner "Test SSH Connection"
        _test_connection_for_host "$target"
    else
        printErrMsg "Host '${target}' not found in your SSH config."
        return 1
    fi
}

# (Private) Ensures prerequisites are met and SSH directory/config are set up.
# Usage: _setup_environment "cmd1" "cmd2" ...
_setup_environment() {
    prereq_checks "$@"
    mkdir -p "$SSH_DIR"; chmod 700 "$SSH_DIR"
    touch "$SSH_CONFIG_PATH"; chmod 600 "$SSH_CONFIG_PATH"
    touch "$PORT_FORWARDS_CONFIG_PATH"; chmod 600 "$PORT_FORWARDS_CONFIG_PATH"
}

# Main application loop.
main_loop() {
    while true; do
        clear
        printBanner "SSH Manager"
        local -a menu_options=(
            "Server Management"
            "Key Management"
            "Port Forwarding"
            "Advanced Tools"
            "Exit"
        )

        local selected_index
        selected_index=$(interactive_single_select_menu "What would you like to do?" "" "${menu_options[@]}")
        [[ $? -ne 0 ]] && { break; }

        case "${menu_options[$selected_index]}" in
        "Server Management") interactive_server_management_view ;;
        "Key Management") interactive_key_management_view ;;
        "Port Forwarding") interactive_port_forward_view ;;
        "Advanced Tools") advanced_menu ;;
        "Exit") break ;;
        esac
    done

    clear
    printOkMsg "Goodbye!"
}

main() {
    # Handle flags first
    if [[ $# -gt 0 ]]; then
        case "$1" in
            -h|--help)
                print_usage
                exit 0
                ;;
            -a|--add)
                # Prereqs for add mode
                _setup_environment "ssh" "ssh-keygen" "ssh-copy-id" "awk" "grep"
                # The add_ssh_host function is fully interactive and self-contained.
                add_ssh_host
                exit 0
                ;;
            -p|--port-forward)
                # Prereqs for port forwarding. ps and kill are for managing forwards.
                _setup_environment "ssh" "awk" "grep" "ps" "kill"
                # The view is self-contained and has its own loop.
                interactive_port_forward_view
                exit 0
                ;;
            -l|--list-hosts)
                # Prereqs for listing hosts.
                _setup_environment "ssh" "awk" "grep"
                list_all_hosts
                exit 0
                ;;
            -f|--list-forwards)
                # Prereqs for listing port forwards.
                _setup_environment "ps" "grep"
                list_active_port_forwards
                exit 0
                ;;
            -c|--connect | -t|--test)
                # Prereqs for connect and test modes are the same
                _setup_environment "ssh" "awk" "grep"
                if [[ "$1" == "-c" || "$1" == "--connect" ]]; then
                    direct_connect
                    # direct_connect either execs or exits, so we shouldn't get here.
                    exit 1
                else
                    # The second argument ($2) is the target for the test.
                    direct_test "$2"
                    exit $?
                fi
                ;;
            *)
                print_usage
                echo
                printErrMsg "Unknown option: $1"
                exit 1
                ;;
        esac
    fi

    # Default interactive mode (no flags)
    _setup_environment "ssh" "ssh-keygen" "ssh-copy-id" "awk" "cat" "grep" "rm" "mktemp" "cp" "date"

    main_loop
}

# This block will only run when the script is executed directly, not when sourced.
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    main "$@"
fi