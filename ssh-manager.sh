#!/bin/bash
# An interactive TUI for managing and connecting to SSH hosts.

# The return value of a pipeline is the status of the last command to exit with a non-zero status.
set -o pipefail

# --- Shared Utilities ---

#region Colors and Styles
export C_RED=$'\033[31m'
export C_GREEN=$'\033[32m'
export C_YELLOW=$'\033[33m'
export C_BLUE=$'\033[34m'
export C_MAGENTA=$'\033[35m'
export C_CYAN=$'\033[36m'
export C_WHITE=$'\033[37m'
export C_GRAY=$'\033[38;5;244m'
export C_L_RED=$'\033[31;1m'
export C_L_GREEN=$'\033[32m'
export C_L_YELLOW=$'\033[33m'
export C_L_BLUE=$'\033[34m'
export C_L_MAGENTA=$'\033[35m'
export C_L_CYAN=$'\033[36m'
export C_L_WHITE=$'\033[37;1m'
export C_L_GRAY=$'\033[38;5;252m'

# Background Colors
export BG_BLACK=$'\033[40;1m'
export BG_RED=$'\033[41m'
export BG_GREEN=$'\033[42;1m'
export BG_YELLOW=$'\033[43m'
export BG_BLUE=$'\033[44m'

export C_BLACK=$'\033[30;1m'

export T_RESET=$'\033[0m'
export T_BOLD=$'\033[1m'
export T_ULINE=$'\033[4m'
export T_REVERSE=$'\033[7m'
export T_CLEAR_LINE=$'\033[K'
export T_CURSOR_HIDE=$'\033[?25l'
export T_CURSOR_SHOW=$'\033[?25h'

export T_ERR="${T_BOLD}${C_L_RED}"
export T_ERR_ICON="[${T_BOLD}${C_RED}✗${T_RESET}]"

export T_OK_ICON="[${T_BOLD}${C_GREEN}✓${T_RESET}]"
export T_INFO_ICON="[${T_BOLD}${C_YELLOW}i${T_RESET}]"
export T_WARN_ICON="[${T_BOLD}${C_YELLOW}!${T_RESET}]"
export T_QST_ICON="[${T_BOLD}${C_L_CYAN}?${T_RESET}]"
#endregion Colors and Styles

export DIV="──────────────────────────────────────────────────────────────────────"

#region Key Codes
export KEY_ESC=$'\033'
export KEY_UP=$'\033[A'
export KEY_DOWN=$'\033[B'
export KEY_RIGHT=$'\033[C'
export KEY_LEFT=$'\033[D'
export KEY_ENTER="ENTER"
export KEY_TAB=$'\t'
export KEY_BACKSPACE=$'\x7f' # ASCII DEL character for backspace
export KEY_HOME=$'\033[H'
export KEY_END=$'\033[F'
export KEY_DELETE=$'\033[3~'
#endregion Key Codes

#region Logging & Banners
printMsg() { printf '%b\n' "$1"; }

printMsgNoNewline() { printf '%b' "$1"; }

printErrMsg() { printMsg "${T_ERR_ICON}${T_ERR} ${1} ${T_RESET}"; }

printOkMsg() { printMsg "${T_OK_ICON} ${1}${T_RESET}"; }

printInfoMsg() { printMsg "${T_INFO_ICON} ${1}${T_RESET}"; }

printWarnMsg() { printMsg "${T_WARN_ICON} ${1}${T_RESET}"; }

# Generates a banner string.
generate_banner_string() {
    local prompt="$1"
    # H1-style banner for top-level calls
    printf '%s' "${C_L_BLUE}+ ${prompt}"$'\n'"${DIV}${T_RESET}"
}

printBanner() {
  # Prints a banner generated by the shared banner logic.
  printMsg "$(generate_banner_string "$1")"
}

# Strips ANSI escape codes from a string.
# This pure-bash version is generally more performant than a sed-based alternative
# for the short strings typically found in this script's UI, as it avoids forking
# external processes.
# Usage: stripped_string=$(strip_ansi_codes "string with colors")
strip_ansi_codes() {
    local s="$1"
    # The C-style escape sequence for ESC
    local esc=$'\033'
    # The regex pattern to match ANSI escape codes. It must be unquoted for the =~ operator.
    local pattern="$esc\\[[0-9;]*[a-zA-Z]"
    # Loop to find and remove all occurrences of the pattern.
    while [[ $s =~ $pattern ]]; do
        # Replace the first match found with an empty string.
        s="${s/${BASH_REMATCH[0]}/}"
    done
    echo -n "$s"
}
#endregion Logging & Banners

#region Terminal Control
clear_current_line() {
    # \e[2K: clear entire line
    # \r: move cursor to beginning of the line
    printf '\033[2K\r' >/dev/tty
}

clear_lines_up() {
    local lines=${1:-1} # Default to 1 line if no argument is provided
    for ((i = 0; i < lines; i++)); do
        # \e[1A: move cursor up one line
        # \e[2K: clear entire line
        printf '\033[1A\033[2K'
    done
    printf '\r' # Move cursor to the beginning of the line
} >/dev/tty

clear_lines_down() {
    local lines=${1:-1}
    if (( lines <= 0 )); then return; fi

    for ((i = 0; i < lines; i++)); do
        # \e[2K: clear entire line
        # \n: move to next line
        printf '\033[2K\n'
    done
    # \e[<N>A: move cursor up N lines
    printf '\033[%sA' "$lines"
} >/dev/tty

move_cursor_up() {
    local lines=${1:-1}
    # Redirect all output of this function to /dev/tty to ensure it works
    # even when the script's stdout is being captured (e.g., in command substitution).
    if (( lines > 0 )); then
        # Using a loop of "up 1" can be more reliable in some terminals
        # than a single "up N" command, which helps prevent screen tearing.
        for ((i = 0; i < lines; i++)); do printf '\033[1A'; done
    fi
    printf '\r' # Move cursor to the beginning of the line
} >/dev/tty
#endregion Terminal Control

#region User Input
read_single_char() {
    local char
    local seq
    # -s: silent, -n 1: one char, -r: raw
    IFS= read -rsn1 char
    # Check for Enter key, which read consumes but returns as an empty string.
    if [[ -z "$char" ]]; then
        echo "$KEY_ENTER"
        return
    fi
    # If the character is ESC, check for a following sequence.
    if [[ "$char" == "$KEY_ESC" ]]; then
        # Try to read the rest of an escape sequence with a short timeout.
        # This loop will continue to read as long as characters are
        # available in the input buffer without a significant delay.
        # This is more robust than reading a fixed number of characters.
        while IFS= read -rsn1 -t 0.001 seq; do
            char+="$seq"
        done
    fi
    echo "$char"
}

prompt_yes_no() {
    local question="$1"
    local default_answer="${2:-}" # Optional second argument
    local prompt_suffix
    local answer

    # Determine the prompt suffix based on the default
    if [[ "$default_answer" == "y" ]]; then
        prompt_suffix="(Y/n)"
    elif [[ "$default_answer" == "n" ]]; then
        prompt_suffix="(y/N)"
    else
        prompt_suffix="(y/n)"
    fi

    while true; do
        printf '%b' "${T_QST_ICON} ${question} ${prompt_suffix} "
        answer=$(read_single_char)
        
        # If the answer is the ENTER key, use the default.
        if [[ "$answer" == "$KEY_ENTER" ]]; then
            answer="$default_answer"
        fi

        case "$answer" in
            [Yy])
                clear_current_line
                return 0 # Success (Yes)
                ;;
            [Nn])
                clear_current_line
                return 1 # Failure (No)
                ;;
            "$KEY_ESC"|"q")
                clear_current_line
                # Don't re-print the (potentially multi-line) question. Just show it was cancelled.
                printMsg " ${C_L_YELLOW}-- cancelled --${T_RESET}"
                return 2 # Cancelled
                ;;
            *)
                clear_current_line
                printErrMsg "Invalid input. Please enter 'y' or 'n'."
                # Loop will continue.
                ;;
        esac
    done
}

prompt_to_continue() {
    printInfoMsg "Press any key to continue..." >/dev/tty
    # Use read_single_char to correctly handle multi-byte sequences like arrow keys,
    # preventing leftover characters in the input buffer. The output is discarded.
    # We redirect to /dev/tty to ensure it works even if stdout is captured.
    read_single_char >/dev/null </dev/tty
    # Clear the "Press any key..." message.
    clear_lines_up 1
}

# --- Interactive Menus ---
# (Private) Generic interactive menu function.
# This is the new core implementation for both single and multi-select menus.
#
# Usage:
#   _interactive_menu <mode> <prompt> <header> <options_array>
#
#   mode: "single" or "multi"
#
# Returns:
#   - For "single" mode: The index of the selected option on stdout.
#   - For "multi" mode: The indices of selected options on stdout, one per line.
#   - Exit code 0 on success, 1 on cancellation or no selection.
_interactive_menu() {
    local mode="$1"; local prompt="$2"; local header="$3"; shift 3; local -a options=("$@")

    if ! [[ -t 0 ]]; then printErrMsg "Not an interactive session." >&2; return 1; fi
    local num_options=${#options[@]}; if [[ $num_options -eq 0 ]]; then printErrMsg "No options provided to menu." >&2; return 1; fi

    local current_option=0; local -a selected_options=()
    if [[ "$mode" == "multi" ]]; then for ((i=0; i<num_options; i++)); do selected_options[i]=0; done; fi

    local header_lines=0
    if [[ -n "$header" ]]; then header_lines=$(echo -e "$header" | wc -l); fi

    _draw_menu_options() {
        local output=""
        for i in "${!options[@]}"; do
            local pointer=" "
            local highlight_start=""
            local highlight_end=""

            if (( i == current_option )); then
                # The current item gets the pointer and reverse-video highlight.
                pointer="${T_BOLD}${C_L_MAGENTA}❯${T_RESET}"
                if [[ "$mode" == "single" ]]; then
                    highlight_start="${T_REVERSE}${C_L_CYAN}"
                else
                    highlight_start="${T_REVERSE}"
                fi
                highlight_end="${T_RESET}"
            elif [[ "$mode" == "multi" ]] && (( selected_options[i] == 1 )); then
                # A selected (but not current) item in multi-select mode gets bolded.
                highlight_start="${T_BOLD}"
                highlight_end="${T_RESET}"
            fi

            if [[ "$mode" == "multi" ]]; then
                local checkbox_text="[ ]"
                local checkbox_style="${T_RESET}"
                if (( selected_options[i] == 1 )); then
                    checkbox_text="[✓]"
                    checkbox_style="${C_GREEN}${T_BOLD}"
                fi
                local option_text="${options[i]}"
                
                if [[ "${options[i]}" == "All" ]]; then
                    # this is the "All" option,
                    # pad it so that highlights take up most of the width
                    option_text=$(printf "%-21s" "${options[i]}")
                fi
                # The highlight is applied to the whole line. The checkbox style is applied only to the checkbox.
                # We reset the checkbox style before the option text, then re-apply the main highlight.
                output+=" ${pointer} ${highlight_start}${checkbox_style}${checkbox_text}${T_RESET}${highlight_start} ${option_text}${T_CLEAR_LINE}${highlight_end}${T_RESET}"$'\n'
            else # single
                output+=" ${pointer} ${highlight_start} ${options[i]} ${T_CLEAR_LINE}${highlight_end}${T_RESET}"$'\n'
            fi
        done
        printf '%s' "$output"
    }

    # --- UI Rendering ---
    printMsgNoNewline "${T_CURSOR_HIDE}" >/dev/tty; trap 'printMsgNoNewline "${T_CURSOR_SHOW}" >/dev/tty' EXIT
    printf '%s\n' "${T_QST_ICON} ${prompt}" >/dev/tty; printf '%s\n' "${C_GRAY}${DIV}${T_RESET}" >/dev/tty
    if [[ -n "$header" ]]; then printf '  %s%s\n' "${header}" "${T_RESET}" >/dev/tty; fi
    _draw_menu_options >/dev/tty
    printf '%s\n' "${C_GRAY}${DIV}${T_RESET}" >/dev/tty

    local movement_keys="↓/↑"
    local select_action="${C_L_GREEN}SPACE/ENTER${C_WHITE} to confirm"
    if [[ "$mode" == "multi" ]]; then
        movement_keys="↓/↑"
        select_action="${C_L_CYAN}SPACE${C_WHITE} to select | ${C_L_GREEN}ENTER${C_WHITE} to confirm"
    fi
    printf '  %s%s%s Move | %s | %s%s%s to cancel%s\n' "${C_L_CYAN}" "${movement_keys}" "${C_WHITE}" "${select_action}" "${C_L_YELLOW}" "Q/ESC" "${C_GRAY}" "${T_RESET}" >/dev/tty

    move_cursor_up 2 # Move to end of options list

    # --- Input Loop ---
    local key; local lines_above=$((2 + header_lines)); local lines_below=2
    while true; do
        move_cursor_up "$num_options"; key=$(read_single_char </dev/tty)
        case "$key" in
            "$KEY_UP"|"k") current_option=$(( (current_option - 1 + num_options) % num_options ));;
            "$KEY_DOWN"|"j") current_option=$(( (current_option + 1) % num_options ));;
            "$KEY_ESC"|"q") clear_lines_down $((num_options + lines_below)); clear_lines_up "$lines_above"; return 1;;
            "$KEY_ENTER")
                clear_lines_down $((num_options + lines_below)); clear_lines_up "$lines_above"
                if [[ "$mode" == "multi" ]]; then
                    local has_selection=0
                    for i in "${!options[@]}"; do if [[ ${selected_options[i]} -eq 1 ]]; then has_selection=1; echo "$i"; fi; done
                    if [[ $has_selection -eq 1 ]]; then return 0; else return 1; fi
                else # single
                    echo "$current_option"; return 0
                fi
                ;;
            ' ')
                if [[ "$mode" == "multi" ]]; then
                    # In multi-select, SPACE toggles, only ENTER confirms.
                    selected_options[current_option]=$(( 1 - selected_options[current_option] ))
                    if [[ "${options[0]}" == "All" ]]; then
                        if (( current_option == 0 )); then local all_state=${selected_options[0]}; for i in "${!options[@]}"; do selected_options[i]=$all_state; done
                        else local all_selected=1; for ((i=1; i<num_options; i++)); do if (( selected_options[i] == 0 )); then all_selected=0; break; fi; done; selected_options[0]=$all_selected; fi
                    fi
                else # single mode: space selects and exits
                    clear_lines_down $((num_options + lines_below)); clear_lines_up "$lines_above"
                    echo "$current_option"; return 0
                fi
                ;;
        esac; _draw_menu_options >/dev/tty; done
}

interactive_multi_select_menu() {
    local prompt="$1"; local header="$2"; shift 2
    _interactive_menu "multi" "$prompt" "$header" "$@"
}

interactive_single_select_menu() {
    local prompt="$1"; local header="$2"; shift 2
    _interactive_menu "single" "$prompt" "$header" "$@"
}

# (Private) A generic, reusable interactive list view.
# This function abstracts the common pattern of displaying a list of items,
# handling navigation, and dispatching actions.
#
# Usage: _interactive_list_view <banner> <header_func> <refresh_func> <key_handler_func> <footer_func>
#   - banner: The title string to display at the top.
#   - header_func: Name of a function that prints the list's column headers.
#   - refresh_func: Name of a function that populates the data arrays. It must accept two
#                   nameref arguments: one for display strings, one for raw data payloads.
#   - key_handler_func: Name of a function to handle key presses. It receives the key, the selected
#                       data payload, the selected index (before move), a nameref to the current index,
#                       the total number of options, and a nameref for the result. It is responsible for
#                       all navigation logic. It must set the result nameref to one of:
#                       "noop" - redraw, "refresh" - reload data, "exit" - close the view.
#   - footer_func: The name of a function that prints the help text at the bottom.
_interactive_list_view() {
    local banner="$1" header_func="$2" refresh_func="$3" key_handler_func="$4" footer_func="$5"

    printMsgNoNewline "${T_CURSOR_HIDE}" >/dev/tty
    trap 'printMsgNoNewline "${T_CURSOR_SHOW}" >/dev/tty' RETURN

    local current_option=0; local -a menu_options=(); local -a data_payloads=(); local num_options=0
    local list_lines=0; local footer_lines=0

    # (Private) Fetches data and clamps the selection index.
    _refresh_data() {
        "$refresh_func" menu_options data_payloads; num_options=${#menu_options[@]}
        if (( current_option >= num_options )); then current_option=$(( num_options - 1 )); fi
        if (( current_option < 0 )); then current_option=0; fi
        # Calculate how many lines the list will render.
        list_lines=0
        if (( num_options > 0 )); then
            for item in "${menu_options[@]}"; do list_lines=$(( list_lines + $(echo -e "$item" | wc -l) )); done
        else
            list_lines=1 # For "(No items found.)"
        fi
    }

    # (Private) Draws only the list portion of the UI.
    _draw_list() {
        if [[ $num_options -gt 0 ]]; then
            for i in "${!menu_options[@]}"; do
                if (( i == current_option )); then
                    local pointer="${T_BOLD}${C_L_MAGENTA}❯${T_RESET}"
                    local selected_line="${menu_options[i]}"
                    selected_line="${selected_line/${T_REVERSE}/''}"; selected_line="${selected_line/${T_RESET}/${T_RESET}${T_REVERSE}}"
                    printMsg " ${pointer} ${T_REVERSE}${selected_line}${T_CLEAR_LINE}${T_RESET}"
                else printMsg "   ${menu_options[i]}${T_CLEAR_LINE}${T_RESET}"; fi
            done
        else printMsg "  ${C_GRAY}(No items found.)${T_CLEAR_LINE}${T_RESET}"; fi
    }

    # (Private) Draws the entire UI from scratch.
    _draw_full_view() {
        clear; printBanner "$banner"; "$header_func"; printMsg "${C_GRAY}${DIV}${T_RESET}"; _draw_list
        printMsg "${C_GRAY}${DIV}${T_RESET}"
        local footer_content; footer_content=$("$footer_func")
        footer_lines=$(echo -e "$footer_content" | wc -l)
        printMsg "$footer_content"
        printMsg "${C_GRAY}${DIV}${T_RESET}"
    }

    _refresh_data # Initial data load
    _draw_full_view

    # Position cursor for the loop: at the end of the list, before the first bottom divider.
    local lines_below_list=$(( footer_lines + 2 ))
    move_cursor_up "$lines_below_list"

    while true; do
        # At this point, the cursor is at the end of the list content.
        # We move up to the start of the list, redraw it, and the cursor will be back at the end of the list.
        move_cursor_up "$list_lines"
        _draw_list

        local key; key=$(read_single_char); local selected_payload=""; if (( num_options > 0 )); then selected_payload="${data_payloads[$current_option]}"; fi
        local handler_result="noop" # Default action is a no-op (redraw list)
        "$key_handler_func" "$key" "$selected_payload" "$current_option" current_option "$num_options" handler_result

        if [[ "$handler_result" == "refresh" ]]; then
            _refresh_data; _draw_full_view
            # After a full redraw, we need to reposition the cursor again for the next loop iteration.
            lines_below_list=$(( footer_lines + 2 ))
            move_cursor_up "$lines_below_list"
        elif [[ "$handler_result" == "exit" ]]; then
            clear; break
        fi
    done
}
#endregion User Input

#region Error Handling & Traps
script_interrupt_handler() {
    trap - INT; clear; printMsg "${T_WARN_ICON} ${C_L_YELLOW}Operation cancelled by user.${T_RESET}"; exit 130; }
trap 'script_interrupt_handler' INT
#endregion Error Handling & Traps

#region Prerequisite & Sanity Checks
_check_command_exists() { command -v "$1" &>/dev/null; }
prereq_checks() {
    local missing_commands=(); printf '%s Running prereq checks' "${T_INFO_ICON}"
    for cmd in "$@"; do printf '%b.%b' "${C_L_BLUE}" "${T_RESET}"; if ! _check_command_exists "$cmd"; then missing_commands+=("$cmd"); fi; done; echo
    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        clear_lines_up 1; printErrMsg "Prerequisite checks failed. Missing commands:"
        for cmd in "${missing_commands[@]}"; do printMsg "    - ${C_L_YELLOW}${cmd}${T_RESET}"; done
        printMsg "${T_INFO_ICON} Please install the missing commands and try again."; exit 1
    fi; clear_lines_up 1
}
#endregion Prerequisite & Sanity Checks

#region Spinners
SPINNER_OUTPUT=""
_run_with_spinner_non_interactive() {
    local desc="$1"; shift; local cmd=("$@"); printMsgNoNewline "${desc} " >&2
    if SPINNER_OUTPUT=$("${cmd[@]}" 2>&1); then printf '%s\n' "${C_L_GREEN}Done.${T_RESET}" >&2; return 0
    else local exit_code=$?; printf '%s\n' "${C_RED}Failed.${T_RESET}" >&2
        while IFS= read -r line; do printf '    %s\n' "$line"; done <<< "$SPINNER_OUTPUT" >&2; return $exit_code; fi
}

_run_with_spinner_interactive() {
    local desc="$1"; shift; local cmd=("$@"); local temp_output_file; temp_output_file=$(mktemp)
    if [[ ! -f "$temp_output_file" ]]; then printErrMsg "Failed to create temp file."; return 1; fi
    local spinner_chars="⣾⣷⣯⣟⡿⢿⣻⣽"; local i=0; "${cmd[@]}" &> "$temp_output_file" &
    local pid=$!; printMsgNoNewline "${T_CURSOR_HIDE}" >&2; trap 'printMsgNoNewline "${T_CURSOR_SHOW}" >&2; rm -f "$temp_output_file"; exit 130' INT TERM
    while ps -p $pid > /dev/null; do
        printf '\r\033[2K' >&2; local line; line=$(tail -n 1 "$temp_output_file" 2>/dev/null | tr -d '\r' || true)
        printf ' %s%s%s  %s' "${C_L_BLUE}" "${spinner_chars:$i:1}" "${T_RESET}" "${desc}" >&2
        if [[ -n "$line" ]]; then printf ' %s[%s]%s' "${C_GRAY}" "${line:0:70}" "${T_RESET}" >&2; fi
        i=$(((i + 1) % ${#spinner_chars})); sleep 0.1; done
    wait $pid; local exit_code=$?; SPINNER_OUTPUT=$(<"$temp_output_file"); rm "$temp_output_file";
    printMsgNoNewline "${T_CURSOR_SHOW}" >&2; trap - INT TERM; clear_current_line >&2
    if [[ $exit_code -eq 0 ]]; then printOkMsg "${desc}" >&2
    else printErrMsg "Task failed: ${desc}" >&2
        while IFS= read -r line; do printf '    %s\n' "$line"; done <<< "$SPINNER_OUTPUT" >&2; fi
    return $exit_code
}

run_with_spinner() {
    if [[ ! -t 1 ]]; then _run_with_spinner_non_interactive "$@"; else _run_with_spinner_interactive "$@"; fi
}

wait_for_pids_with_spinner() {
    local desc="$1"; shift; local pids_to_wait_for=("$@")
    if [[ ! -t 1 ]]; then
        printMsgNoNewline "    ${T_INFO_ICON} ${desc}... " >&2;
        if wait "${pids_to_wait_for[@]}"; then printf '%s\n' "${C_L_GREEN}Done.${T_RESET}" >&2; return 0
        else local exit_code=$?; printf '%s\n' "${C_RED}Failed (wait command exit code: $exit_code).${T_RESET}" >&2; return $exit_code; fi
    fi
    _spinner() {
        local spinner_chars="⣾⣷⣯⣟⡿⢿⣻⣽"; local i=0;
        while true; do printf '\r\033[2K' >&2; printf '    %s%s%s %s' "${C_L_BLUE}" "${spinner_chars:$i:1}" "${T_RESET}" "${desc}" >&2; i=$(((i + 1) % ${#spinner_chars})); sleep 0.1; done;
    }
    printMsgNoNewline "${T_CURSOR_HIDE}" >&2
    _spinner &
    local spinner_pid=$!
    trap 'kill "$spinner_pid" &>/dev/null; printMsgNoNewline "${T_CURSOR_SHOW}" >&2; exit 130' INT TERM
    wait "${pids_to_wait_for[@]}"; local exit_code=$?
    kill "$spinner_pid" &>/dev/null; printMsgNoNewline "${T_CURSOR_SHOW}" >&2; trap - INT TERM; clear_current_line >&2
    if [[ $exit_code -eq 0 ]]; then printOkMsg "${desc}" >&2
    else printErrMsg "Wait command failed with exit code ${exit_code} for task: ${desc}" >&2; fi
    return $exit_code
}
#endregion Spinners

# --- Constants ---
SSH_DIR="${SSH_DIR:-${HOME}/.ssh}"
SSH_CONFIG_PATH="${SSH_CONFIG_PATH:-${SSH_DIR}/config}"
PORT_FORWARDS_CONFIG_PATH="${PORT_FORWARDS_CONFIG_PATH:-${SSH_DIR}/port_forwards.conf}"

# --- Script Functions ---

print_usage() {
    printBanner "SSH Connection Manager"
    printMsg "An interactive TUI to manage and connect to SSH hosts in:\n ${C_L_BLUE}${SSH_CONFIG_PATH}${T_RESET}"
    printMsg "\n${T_ULINE}Usage:${T_RESET}"
    printMsg "  $(basename "$0") [option]"
    printMsg "\nThis script is fully interactive.\nRun without arguments to launch the main menu."
    printMsg "\n${T_ULINE}Options:${T_RESET}"
    printMsg "  ${C_L_BLUE}-c, --connect${T_RESET}      Go directly to host selection for connecting"
    printMsg "  ${C_L_BLUE}-a, --add${T_RESET}      Go directly to the 'Add a new server' menu"
    printMsg "  ${C_L_BLUE}-p, --port-forward${T_RESET} Go directly to the 'Port Forwarding' menu"
    printMsg "  ${C_L_BLUE}-l, --list-hosts${T_RESET}    List all configured hosts and exit"
    printMsg "  ${C_L_BLUE}-f, --list-forwards${T_RESET}  List active port forwards and exit"
    printMsg "  ${C_L_BLUE}-t, --test [host|all]${T_RESET}  Test connection to a host, all hosts, or show menu"
    printMsg "  ${C_L_BLUE}-h, --help${T_RESET}     Show this help message"
}

# Parses the SSH config file to extract host aliases.
# Ignores wildcard hosts like '*'.
get_ssh_hosts() {
    if [[ ! -f "$SSH_CONFIG_PATH" ]]; then
        return
    fi
    # Use awk to find lines starting with "Host", print the second field,
    # and ignore any hosts that are just "*".
    awk '/^[Hh]ost / && $2 != "*" {print $2}' "$SSH_CONFIG_PATH"
}

# Gets a specific config value for a given host by using `ssh -G`.
# This is the most robust method as it uses ssh itself to evaluate the config.
# It correctly handles the "first value wins" rule for duplicate keys, as well
# as Match blocks and include directives.
# Usage: get_ssh_config_value <host_alias> <config_key>
get_ssh_config_value() {
    local host_alias="$1"
    local key="$2"
    local key_lower
    key_lower=$(echo "$key" | tr '[:upper:]' '[:lower:]')

    # `ssh -G` prints the fully resolved configuration for a host.
    ssh -G "$host_alias" 2>/dev/null | awk -v key="$key_lower" '
        $1 == key {
            # The value is the rest of the line. This handles values with spaces.
            val = ""
            for (i = 2; i <= NF; i++) {
                val = (val ? val " " : "") $i
            }
            print val
            exit
        }
    '
}

# (Private) Gets a config value ONLY if it's explicitly set in the host block.
# This avoids picking up default values that `ssh -G` provides.
# Returns an empty string if the key is not explicitly set in the block.
# Usage: _get_explicit_ssh_config_value <host_alias> <config_key>
_get_explicit_ssh_config_value() {
    local host_alias="$1"
    local key_lower
    key_lower=$(echo "$2" | tr '[:upper:]' '[:lower:]')

    local host_block
    host_block=$(_get_host_block_from_config "$host_alias" "$SSH_CONFIG_PATH")

    if [[ -n "$host_block" ]]; then
        # Parse the block for the specific key, ignoring case for the key itself.
        echo "$host_block" | awk -v key="$key_lower" '
            tolower($1) == key {
                val = ""; for (i = 2; i <= NF; i++) { val = (val ? val " " : "") $i }; print val; exit
            }
        '
    fi
}

# (Private) Gets all relevant config values for a given host in one go.
# Returns a string of `eval`-safe variable assignments.
# Usage:
#   local details; details=$(_get_all_ssh_config_values_as_string <host_alias>)
#   eval "$details"
_get_all_ssh_config_values_as_string() {
    local host_alias="$1"
    # Call ssh -G once per host and parse all required values in a single awk command.
    # This is much more efficient than calling ssh -G multiple times.
    ssh -G "$host_alias" 2>/dev/null | awk '
        # Map ssh -G output keys to the shell variable names we want to use.
        BEGIN {
            keys["hostname"] = "current_hostname"
            keys["user"] = "current_user"
            # identityfile is now handled separately to avoid ssh -G defaults
            keys["port"] = "current_port"
        }
        # If the first field is one of our target keys, process it.
        $1 in keys {
            var_name = keys[$1]
            # Reconstruct the value, which might contain spaces.
            val = ""
            for (i = 2; i <= NF; i++) { val = (val ? val " " : "") $i }
            # Print in KEY="VALUE" format for safe evaluation in the shell.
            printf "%s=\"%s\"\n", var_name, val
        }
    '
}

# (Private) Generic function to process an SSH config file, filtering host blocks.
# It can either keep only the matching block or remove it and keep everything else.
# Usage: _process_ssh_config_blocks <target_host> <config_file> <mode>
#   mode: 'keep' - prints only the block matching the target_host.
#   mode: 'remove' - prints the entire file except for the matching block.
_process_ssh_config_blocks() {
    local target_host="$1"
    local config_file="$2"
    local mode="$3" # 'keep' or 'remove'

    if [[ "$mode" != "keep" && "$mode" != "remove" ]]; then
        printErrMsg "Invalid mode '${mode}' for _process_ssh_config_blocks" >&2
        return 1
    fi

    awk -v target_host="$target_host" -v mode="$mode" '
        # Flushes the buffered block based on whether it matches the target and the desired mode.
        # It manages a single newline separator between printed blocks.
        function flush_block() {
            if (block != "") {
                if ((mode == "keep" && is_target_block) || (mode == "remove" && !is_target_block)) {
                    # If we have printed a block before, add a newline separator.
                    if (output_started) {
                        printf "\n"
                    }
                    printf "%s", block
                    output_started = 1
                }
            }
        }

        # Match a new Host block definition.
        /^[ \t]*[Hh][Oo][Ss][Tt][ \t]+/ {
            flush_block() # Flush the previous block.

            # Reset state for the new block.
            block = $0
            is_target_block = 0

            # Check if this new block is the one we are looking for by iterating
            # through the fields on the line, starting from the second field.
            for (i = 2; i <= NF; i++) {
                if ($i ~ /^#/) break # Stop at the first comment
                if ($i == target_host) {
                    is_target_block = 1
                    break
                }
            }
            next
        }

        # For any other line (part of a block, a comment, or a blank line):
        {
            if (block != "") {
                block = block "\n" $0
            } else {
                # This is content before the first Host definition.
                # It is never a target block, so print it only in "remove" mode.
                if (mode == "remove") {
                    printf "%s\n", $0
                    output_started = 1
                }
            }
        }

        # At the end of the file, flush the last remaining block.
        END {
            flush_block()
            if (output_started) {
                printf "\n"
            }
        }
    ' "$config_file"
}

# (Private) Reads an SSH config file and returns the block for a specific host.
# Usage:
#   local block
#   block=$(_get_host_block_from_config "my-host" "/path/to/config")
_get_host_block_from_config() {
    local host_to_find="$1"
    local config_file="$2"
    _process_ssh_config_blocks "$host_to_find" "$config_file" "keep"
}

# (Private) Reads the SSH config and returns a new version with a specified host block removed.
# Usage:
#   local new_config
#   new_config=$(_remove_host_block_from_config "my-host")
#   echo "$new_config" > "$SSH_CONFIG_PATH"
_remove_host_block_from_config() {
    local host_to_remove="$1"
    _process_ssh_config_blocks "$host_to_remove" "$SSH_CONFIG_PATH" "remove"
}

# (Private) Helper function to rename both private and public key files.
# This is designed to be called by `run_with_spinner`.
# Usage: _rename_key_pair <old_base_path> <new_base_path>
_rename_key_pair() {
    local old_base="$1"
    local new_base="$2"
    # The `&&` ensures we only try to move the public key if the private key move succeeds.
    mv "${old_base}" "${new_base}" && mv "${old_base}.pub" "${new_base}.pub"
}

# Generates a list of formatted strings for the interactive menu,
# showing details for each SSH host.
# Populates an array whose name is passed as the first argument.
# Usage:
#   local -a my_menu_options
#   get_detailed_ssh_hosts_menu_options my_menu_options
get_detailed_ssh_hosts_menu_options() {
    local -n out_array="$1" # Use nameref to populate the caller's array
    local show_key_info="${2:-true}"
    local -a hosts
    mapfile -t hosts < <(get_ssh_hosts)

    out_array=() # Clear the output array

    if [[ ${#hosts[@]} -eq 0 ]]; then
        return 0 # Not an error, just no hosts
    fi

    for host_alias in "${hosts[@]}"; do
        # Declare local variables and use eval to populate them from the awk output.
        # This is safe because the input is controlled (from ssh -G) and the awk script
        # only processes specific, known keys.
        local current_hostname current_user current_identityfile current_port
        local details; details=$(_get_all_ssh_config_values_as_string "$host_alias") # Gets hostname, user, port
        eval "$details" # Sets the variables

        # Now, explicitly get the identity file to avoid using ssh -G defaults.
        current_identityfile=$(_get_explicit_ssh_config_value "$host_alias" "IdentityFile")

        # Clean up identity file path for display
        local key_info=""
        if [[ "$show_key_info" == "true" && -n "$current_identityfile" ]]; then
            # Using #$HOME is safer than a simple string replacement
            # Color the path white, then switch back to cyan for the closing parenthesis.
            key_info=" (${C_WHITE}${current_identityfile/#$HOME/\~}${C_L_CYAN})"
        fi

        # Format port info, only show if not the default port 22
        local port_info=""
        if [[ -n "$current_port" && "$current_port" != "22" ]]; then
            # Color the port yellow, then switch back to the base cyan color.
            port_info=":${C_L_YELLOW}${current_port}${C_L_CYAN}"
        fi

        # Build the details part of the string with all its colors.
        local details_string="${C_L_CYAN}${current_user:-?}@${current_hostname:-?}${port_info}${key_info}"

        # Use a simple printf to combine the padded host alias and the details string.
        # This is more robust than having color codes inside the printf format string.
        local formatted_string; formatted_string=$(printf "%-20b %b${T_RESET}" "${host_alias}" "${details_string}"
        )
        out_array+=("$formatted_string")
    done
}

# Presents an interactive menu for the user to select an SSH host.
# Returns the selected host alias via stdout.
# Returns exit code 1 if no host is selected or none exist.
# Usage:
#   local selected_host
#   selected_host=$(select_ssh_host "Select a host to connect to:")
#   if [[ $? -eq 0 ]]; then ...
select_ssh_host() {
    local prompt="$1"
    local show_key_info="${2:-true}"
    mapfile -t hosts < <(get_ssh_hosts)
    if [[ ${#hosts[@]} -eq 0 ]]; then
        printInfoMsg "No hosts found in your SSH config file."
        return 1
    fi

    local -a menu_options
    get_detailed_ssh_hosts_menu_options menu_options "$show_key_info"

    local selected_index
    local header
    header=$(printf "  %-20s ${C_WHITE}%s${T_RESET}" "HOST ALIAS" "user@hostname[:port]")
    selected_index=$(interactive_single_select_menu "$prompt" "$header" "${menu_options[@]}")
    if [[ $? -ne 0 ]]; then
        printInfoMsg "Operation cancelled."
        return 1
    fi

    echo "${hosts[$selected_index]}"
    return 0
}

# Helper function that does the actual ssh-copy-id work
copy_ssh_id_for_host() {
    local host_alias="$1"
    local key_file="$2"
    
    # By using the host_alias directly, ssh-copy-id will respect all settings
    # in the ~/.ssh/config file for that host, including User, HostName, and Port.
    # This is more robust than manually extracting values.
    printInfoMsg "Attempting to copy key to '${host_alias}'..."
    printMsg "You may be prompted for the password for the remote user."

    # ssh-copy-id is interactive, so we run it directly in the foreground.
    if ssh-copy-id -i "$key_file" "$host_alias"; then
        printOkMsg "Key successfully copied to '${host_alias}'."
    else
        printErrMsg "Failed to copy key to '${host_alias}'."
        printInfoMsg "Check your network connection, password, and server's SSH configuration."
        return 1
    fi
}

# (Private) Continues the key generation process after a type has been selected.
# This is designed to be called from the interactive view or the full-screen wizard.
# Usage: _generate_ssh_key_from_type "ed25519 (recommended)"
_generate_ssh_key_from_type() {
    local key_type_selection="$1"

    local key_type="ed25519" # Default
    local -a key_bits_args=()
    if [[ "$key_type_selection" == "rsa (legacy, 4096 bits)" ]]; then
        key_type="rsa"
        key_bits_args=("-b" "4096")
    fi

    local key_filename
    prompt_for_input "Enter filename for the new key (in ${SSH_DIR})" key_filename "id_${key_type}" || return
    local full_key_path="${SSH_DIR}/${key_filename}"

    if [[ -f "$full_key_path" ]]; then
        if ! prompt_yes_no "Key file '${full_key_path}' already exists. Overwrite it?" "n"; then
            printInfoMsg "Key generation cancelled."
            return
        fi
    fi

    local key_comment
    prompt_for_input "Enter a comment for the key" key_comment "${USER}@$(hostname)" || return

    if run_with_spinner "Generating new ${key_type} key..." \
        ssh-keygen -t "${key_type}" "${key_bits_args[@]}" -f "${full_key_path}" -N "" -C "${key_comment}"; then
        printInfoMsg "Key pair created:"
        printMsg "  Private key: ${C_L_BLUE}${full_key_path/#$HOME/\~}${T_RESET}"
        printMsg "  Public key:  ${C_L_BLUE}${full_key_path/#$HOME/\~}.pub${T_RESET}"
    else
        # run_with_spinner already prints the error details.
        printErrMsg "Failed to generate SSH key."
    fi
}

# (Private) A wrapper for _generate_ssh_key_from_type that adds a banner.
# This is intended to be called by `run_menu_action`.
_generate_ssh_key_from_type_with_banner() {
    printBanner "Add New SSH Key"
    _generate_ssh_key_from_type "$1"
}

# Adds a new SSH key pair without associating it with a host.
generate_ssh_key() {
    printBanner "Add New SSH Key"

    local -a key_types=("ed25519 (recommended)" "rsa (legacy, 4096 bits)")
    local selected_index
    selected_index=$(interactive_single_select_menu "Select the type of key to generate:" "" "${key_types[@]}")
    [[ $? -ne 0 ]] && { printInfoMsg "Operation cancelled."; return; }

    # The worker function will now handle the rest of the prompts.
    _generate_ssh_key_from_type "${key_types[$selected_index]}"
}

# Prompts user to select a host and then copies the specified key.
copy_selected_ssh_key() {
    local selected_key="$1"
    printBanner "Copy SSH Key to Server"
    printInfoMsg "Selected key: ${C_L_BLUE}${selected_key/#$HOME/\~}${T_RESET}"

    local selected_host
    selected_host=$(select_ssh_host "Select a host to copy this key to:")
    [[ $? -ne 0 ]] && return

    copy_ssh_id_for_host "$selected_host" "$selected_key"
}

# Deletes an SSH key pair (private and public files).
delete_ssh_key() {
    local key_base_path="$1"
    local pub_key_path="${key_base_path}.pub"
    printBanner "Delete SSH Key Pair"

    if ! [[ -f "$key_base_path" ]]; then
        printErrMsg "Private key not found: ${key_base_path}"
        return 1
    fi

    local question="Are you sure you want to permanently delete this key pair?\n  Private: ${key_base_path}"
    if [[ -f "$pub_key_path" ]]; then
        question+="\n  Public:  ${pub_key_path}"
    else
        question+="\n  (Public key not found, will only delete private key)"
    fi

    if prompt_yes_no "$question" "n"; then
        if run_with_spinner "Deleting key pair..." rm -f "$key_base_path" "$pub_key_path"; then
            printOkMsg "Key pair deleted."
        else
            printErrMsg "Failed to delete key pair."
        fi
    else
        printInfoMsg "Deletion cancelled."
    fi
}

# Renames an SSH key pair.
rename_ssh_key() {
    local old_key_path="$1"
    printBanner "Rename SSH Key"
    local new_key_filename
    local old_filename; old_filename=$(basename "$old_key_path")
    prompt_for_input "Enter new filename for the key (in ${SSH_DIR})" new_key_filename "$old_filename" || return
    local new_key_path="${SSH_DIR}/${new_key_filename}"

    if [[ "$new_key_path" == "$old_key_path" ]]; then
        printInfoMsg "Filename is unchanged. No action taken."
        return
    fi
    if [[ -f "$new_key_path" || -f "${new_key_path}.pub" ]]; then
        printErrMsg "Target key file '${new_key_path/#$HOME/\~}' or its .pub already exists. Aborting."
        return 1
    fi

    if run_with_spinner "Renaming key files..." _rename_key_pair "$old_key_path" "$new_key_path"; then
        printOkMsg "Key renamed successfully."
        printInfoMsg "Note: You must manually update any SSH host configs that used the old key name."
    else
        printErrMsg "Failed to rename key files."
        return 1
    fi
}

# Displays the content of a public key file.
view_public_key() {
    local pub_key_path="$1"
    printBanner "View Public Key"
    if [[ ! -f "$pub_key_path" ]]; then printErrMsg "Public key file not found: ${pub_key_path/#$HOME/\~}"; return 1; fi
    printInfoMsg "Contents of ${C_L_BLUE}${pub_key_path/#$HOME/\~}${T_RESET}:"
    printMsg "${C_GRAY}${DIV}${T_RESET}"
    printMsg "${C_L_GRAY}$(cat "${pub_key_path}")${T_RESET}"
    printMsg "${C_GRAY}${DIV}${T_RESET}"
}

# (Private) Worker for regenerating a public key, for use with run_with_spinner.
_regenerate_public_key_worker() {
    # ssh-keygen -y reads from the private key file and writes the public key to stdout.
    ssh-keygen -y -f "$1" > "$2"
}

# Re-generates a public key from a private key file.
regenerate_public_key() {
    local private_key_path="$1"
    local public_key_path="${private_key_path}.pub"
    printBanner "Re-generate Public Key"

    if [[ ! -f "$private_key_path" ]]; then
        printErrMsg "Private key not found: ${private_key_path/#$HOME/\~}"
        return 1
    fi

    if [[ -f "$public_key_path" ]]; then
        if ! prompt_yes_no "Public key '${public_key_path/#$HOME/\~}' already exists. Overwrite it?" "n"; then
            printInfoMsg "Operation cancelled."
            return
        fi
    fi

    if run_with_spinner "Re-generating public key..." _regenerate_public_key_worker "$private_key_path" "$public_key_path"; then
        printOkMsg "Public key successfully generated at: ${C_L_BLUE}${public_key_path/#$HOME/\~}${T_RESET}"
    else
        printErrMsg "Failed to re-generate public key."
    fi
}

# An interactive prompt for user input that supports cancellation.
# It provides a rich line-editing experience including cursor movement
# (left/right/home/end), insertion, and deletion (backspace/delete).
# Usage: prompt_for_input "Prompt text" "variable_name" ["default_value"] ["allow_empty"]
# Returns 0 on success (Enter), 1 on cancellation (ESC).
prompt_for_input() {
    local prompt_text="$1"
    local -n var_ref="$2" # Use nameref to assign to caller's variable
    local default_val="${3:-}"
    local allow_empty="${4:-false}"

    # Pre-fill the input string with the default value.
    local input_str="$default_val"
    # Cursor position is the index of the character *before* which to insert.
    # 0 is the beginning, length is the end.
    local cursor_pos=${#input_str}
    local key

    while true; do
        # Draw the prompt and current input string.
        clear_current_line >/dev/tty
        printMsgNoNewline "${T_QST_ICON} ${prompt_text}: ${C_L_CYAN}${input_str}${T_RESET}" >/dev/tty

        # Move cursor to the correct position within the input string.
        # The cursor is currently at the end of the line. We need to move it
        # left by the number of characters that are *after* the cursor position.
        local chars_after_cursor=$(( ${#input_str} - cursor_pos ))
        if (( chars_after_cursor > 0 )); then
            # \033[<N>D moves cursor left N columns
            printf '\033[%sD' "$chars_after_cursor" >/dev/tty
        fi

        key=$(read_single_char </dev/tty)

        case "$key" in
            "$KEY_ENTER")
                if [[ -n "$input_str" || "$allow_empty" == "true" ]]; then
                    var_ref="$input_str"
                    clear_current_line >/dev/tty
                    # Show the prompt again with the final selected value.
                    printMsg "${T_QST_ICON} ${prompt_text}: ${C_L_GREEN}${var_ref}${T_RESET}"
                    return 0 # Success
                fi
                # If not valid (empty and not allowed), loop continues.
                ;;
            "$KEY_ESC")
                clear_current_line >/dev/tty
                printf '%b\n' "${T_QST_ICON} ${prompt_text}:"$'\n'" ${C_L_YELLOW}-- cancelled --${T_RESET}" >/dev/tty
                return 1 # Cancelled
                ;;
            "$KEY_BACKSPACE")
                if (( cursor_pos > 0 )); then
                    # Remove character before the cursor
                    input_str="${input_str:0:cursor_pos-1}${input_str:cursor_pos}"
                    ((cursor_pos--))
                fi
                ;;
            "$KEY_DELETE")
                if (( cursor_pos < ${#input_str} )); then
                    # Remove character at the cursor
                    input_str="${input_str:0:cursor_pos}${input_str:cursor_pos+1}"
                    # cursor_pos does not change
                fi
                ;;
            "$KEY_LEFT")
                if (( cursor_pos > 0 )); then ((cursor_pos--)); fi
                ;;
            "$KEY_RIGHT")
                if (( cursor_pos < ${#input_str} )); then ((cursor_pos++)); fi
                ;;
            "$KEY_HOME")
                cursor_pos=0
                ;;
            "$KEY_END")
                cursor_pos=${#input_str}
                ;;
            *)
                # Append single, printable characters. Ignore control sequences.
                if (( ${#key} == 1 )) && [[ "$key" =~ [[:print:]] ]]; then
                    # Insert character at cursor position
                    input_str="${input_str:0:cursor_pos}${key}${input_str:cursor_pos}"
                    ((cursor_pos++))
                fi
                ;;
        esac
    done
}

# (Private) Handles the logic for selecting an existing key.
# Returns the path to the selected key via a nameref.
# Usage: _select_and_get_existing_key identity_file_var
# Returns 0 on success, 1 on cancellation/failure.
_select_and_get_existing_key() {
    local -n out_identity_file="$1"
    local -a pub_keys
    mapfile -t pub_keys < <(find "$SSH_DIR" -maxdepth 1 -type f -name "*.pub")
    if [[ ${#pub_keys[@]} -eq 0 ]]; then
        printErrMsg "No existing SSH keys (.pub files) found in ${SSH_DIR}."
        return 1
    fi

    local -a private_key_paths
    local -a display_paths
    for pub_key in "${pub_keys[@]}"; do
        local private_key="${pub_key%.pub}"
        private_key_paths+=("$private_key")
        display_paths+=("${private_key/#$HOME/\~}")
    done

    local key_idx
    key_idx=$(interactive_single_select_menu "Select the private key to use:" "" "${display_paths[@]}") || return 1
    out_identity_file="${private_key_paths[$key_idx]}"
    return 0
}

# (Private) Builds a host block as a string. Does not write to any file.
# Usage: _build_host_block_string <alias> <hostname> <user> <port> [identity_file]
_build_host_block_string() {
    local host_alias="$1"
    local host_name="$2"
    local user="$3"
    local port="$4"
    local identity_file="${5:-}"

    # Use a subshell to capture the output of multiple echo commands
    {
        echo "Host ${host_alias}"
        echo "    HostName ${host_name}"
        echo "    User ${user}"
        if [[ -n "$port" && "$port" != "22" ]]; then
            echo "    Port ${port}"
        fi
        if [[ -n "$identity_file" ]]; then
            echo "    IdentityFile ${identity_file}"
            echo "    IdentitiesOnly yes"
        fi
    }
}

# (Private) Appends a fully formed host block to the SSH config file.
# Usage: _append_host_to_config <alias> <hostname> <user> <port> [identity_file]
_append_host_to_config() {
    local host_alias="$1"
    local host_name="$2"
    local user="$3"
    local port="$4"
    local identity_file="${5:-}"

    (
        echo "" # Separator
        _build_host_block_string "$host_alias" "$host_name" "$user" "$port" "$identity_file"
    ) >> "$SSH_CONFIG_PATH"

    local key_msg=""
    if [[ -n "$identity_file" ]]; then
        key_msg=" with key ${identity_file/#$HOME/\~}"
    fi
    printOkMsg "Host '${host_alias}' added to ${SSH_CONFIG_PATH}${key_msg}."
}

# (Private) Prompts for a new, unique SSH host alias.
# It allows the user to re-enter an existing alias, which is treated as a no-op if it's the "old" one.
# Uses a nameref to return the value.
# Usage: _prompt_for_unique_host_alias alias_var [prompt_text] [old_alias_to_allow] [default_value]
# Returns 0 on success, 1 on cancellation.
_prompt_for_unique_host_alias() {
    local out_alias_var_name="$1"
    local -n out_alias_var="$out_alias_var_name" # Use a nameref for easier value access/modification internally.
    local prompt_text="${2:-Enter a short alias for the host}"
    local old_alias_to_allow="${3:-}"
    local default_value="${4:-}"

    while true; do
        # Pass the default value, which might be the old alias or the user's previous (invalid) input.
        prompt_for_input "$prompt_text" "$out_alias_var_name" "$default_value" || return 1

        # If renaming and the user entered the old name, it's a valid "no-op" choice.
        if [[ -n "$old_alias_to_allow" && "$out_alias_var" == "$old_alias_to_allow" ]]; then
            return 0
        fi

        # Check if host alias already exists in the main config file.
        if get_ssh_hosts | grep -qFx "$out_alias_var"; then
            printErrMsg "Host alias '${out_alias_var}' already exists. Please choose another."
            # Set the default for the next loop iteration to what the user just typed.
            default_value="$out_alias_var"
        else
            return 0 # Alias is unique, success
        fi
    done
}

# --- Host Editor Feature (Private Helpers) ---

# (Private) Generic UI for the interactive host editors (add, edit, clone).
# This single function replaces _draw_interactive_add_host_ui, _draw_interactive_edit_host_ui,
# and _draw_interactive_clone_host_ui, reducing code duplication.
# Usage: _draw_interactive_host_editor_ui <mode> <new_alias> <new_hostname> ... <original_alias> ...
_draw_interactive_host_editor_ui() {
    local mode="$1"
    local new_alias="$2" new_hostname="$3" new_user="$4" new_port="$5" new_identityfile="$6"
    local original_alias="$7" original_hostname="$8" original_user="$9" original_port="${10}" original_identityfile="${11}"

    # Helper to format a line, adding a change indicator (*) if needed.
    _format_line() {
        local key="$1" label="$2" new_val="$3" original_val="$4" is_alias="${5:-false}"

        local display_val="${new_val}"; if [[ "$label" == "IdentityFile" ]]; then display_val="${new_val/#$HOME/\~}"; fi
        if [[ -z "$display_val" ]]; then display_val="${C_GRAY}(not set)${T_RESET}"; else display_val="${C_L_CYAN}${display_val}${T_RESET}"; fi

        local change_indicator=" "
        # In 'add' mode, there are no "changes" from an original, so no indicator.
        if [[ "$mode" != "add" ]]; then
            if [[ "$is_alias" == "true" ]]; then
                if [[ "$new_val" != "$original_val" ]]; then change_indicator="${C_L_YELLOW}*${T_RESET}"; fi
            else
                local expanded_new_val="${new_val/#\~/$HOME}"
                if [[ "$expanded_new_val" != "${original_val/#\~/$HOME}" ]]; then change_indicator="${C_L_YELLOW}*${T_RESET}"; fi
            fi
        fi

        # For clone mode, the alias is always considered a change.
        if [[ "$mode" == "clone" && "$label" == "Host (Alias)" ]]; then change_indicator="${C_L_YELLOW}*${T_RESET}"; fi

        printf "  ${C_L_WHITE}%s)${T_RESET} %b %-15s: %b\n" "$key" "$change_indicator" "$label" "$display_val"
    }

    local title="Configure the host details:"
    if [[ "$mode" == "add" ]]; then title="Configure the new host:"; fi
    if [[ "$mode" == "clone" ]]; then title="Configure the new cloned host:"; fi
    printMsg "$title"

    _format_line "1" "Host (Alias)" "$new_alias" "$original_alias" "true"
    _format_line "2" "HostName"     "$new_hostname" "$original_hostname"
    _format_line "3" "User"         "$new_user" "$original_user"
    _format_line "4" "Port"         "$new_port" "$original_port"
    _format_line "5" "IdentityFile" "$new_identityfile" "$original_identityfile"

    echo
    local discard_text="iscard all pending changes"
    if [[ "$mode" == "add" ]]; then discard_text="eset fields"; fi
    printMsg "  ${C_L_WHITE}c) ${C_L_YELLOW}(C)ancel/(D)${discard_text}${T_RESET}"
    printMsg "  ${C_L_WHITE}s) ${C_L_GREEN}(S)ave${T_RESET} and Quit"
    printMsg "  ${C_L_WHITE}q) ${C_L_YELLOW}(Q)uit${T_RESET} without saving (or press ${C_L_YELLOW}ESC${T_RESET})"
    echo
    printMsgNoNewline "${T_QST_ICON} Your choice: "
}

# (Private) Interactively prompts the user to select or create an IdentityFile when editing a host.
# This provides a menu-driven alternative to manually typing a file path.
# Usage: _prompt_for_identity_file_interactive <out_var> <current_path> <host_alias> <user> <hostname>
# Returns 0 on success, 1 on cancellation.
_prompt_for_identity_file_interactive() {
    local -n out_identity_file="$1"
    local current_identity_file="$2"
    local host_alias="$3"
    local user="$4"
    local hostname="$5"

    while true; do
        local -a menu_options=()
        local -a option_values=() # Parallel array to hold the real values

        # Option: Keep current
        if [[ -n "$current_identity_file" ]]; then
            menu_options+=("Keep current: ${C_L_GREEN}${current_identity_file/#$HOME/\~}${T_RESET}")
            option_values+=("$current_identity_file")
        fi

        # Option: Remove
        menu_options+=("Remove IdentityFile entry")
        option_values+=("__REMOVE__")

        # Option: Generate new
        menu_options+=("Generate a new dedicated key (ed25519)...")
        option_values+=("__GENERATE__")

        # Find existing private keys to offer as choices
        local -a existing_keys=()
        mapfile -t pub_keys < <(find "$SSH_DIR" -maxdepth 1 -type f -name "*.pub")
        if [[ ${#pub_keys[@]} -gt 0 ]]; then
            for pub_key in "${pub_keys[@]}"; do
                local private_key="${pub_key%.pub}"
                # Only add if it's not the currently selected key
                if [[ "$private_key" != "$current_identity_file" ]]; then
                    existing_keys+=("$private_key")
                fi
            done
        fi

        if [[ ${#existing_keys[@]} -gt 0 ]]; then
            menu_options+=("--- Select an existing key ---")
            option_values+=("__SEPARATOR__")
            for key in "${existing_keys[@]}"; do
                menu_options+=("  ${key/#$HOME/\~}")
                option_values+=("$key")
            done
        fi

        local selected_index
        selected_index=$(interactive_single_select_menu "Select an IdentityFile option for '${host_alias}':" "" "${menu_options[@]}")
        if [[ $? -ne 0 ]]; then return 1; fi # User cancelled

        local selected_value="${option_values[$selected_index]}"

        case "$selected_value" in
            "__SEPARATOR__") continue ;; # Loop to redraw menu
            "__REMOVE__") out_identity_file=""; return 0 ;;
            "__GENERATE__")
                local new_key_filename; local default_key_name="${host_alias}_id_ed25519"
                prompt_for_input "Enter filename for new key (in ${SSH_DIR})" new_key_filename "$default_key_name" || continue
                local new_key_path="${SSH_DIR}/${new_key_filename}"
                if [[ -f "$new_key_path" ]] && ! prompt_yes_no "Key file '${new_key_path}' already exists.\n    Overwrite?" "n"; then
                    printInfoMsg "Key generation cancelled."; continue
                fi
                if run_with_spinner "Generating new ed25519 key..." ssh-keygen -t ed25519 -f "$new_key_path" -N "" -C "${user}@${hostname}"; then
                    out_identity_file="$new_key_path"; return 0
                else printErrMsg "Failed to generate key."; prompt_to_continue; continue; fi ;;
            *) out_identity_file="$selected_value"; return 0 ;;
        esac
    done
}

# --- Host Lifecycle Functions ---

# Prompts user for details and adds a new host to the SSH config from scratch.
add_ssh_host_from_scratch() {
    printBanner "Add New SSH Host"

    # --- Create from scratch logic ---
    local initial_alias="" initial_hostname="" initial_user="$USER" initial_port="22" initial_identityfile=""
    local new_alias="$initial_alias" new_hostname="$initial_hostname" new_user="$initial_user" new_port="$initial_port" new_identityfile="$initial_identityfile"

    local banner_text="Add New SSH Host"

    # Call the shared editor loop. It will modify the 'new_*' variables.
    if ! _interactive_host_editor_loop "add" "$banner_text" \
        new_alias new_hostname new_user new_port new_identityfile \
        "$initial_alias" "$initial_hostname" "$initial_user" "$initial_port" "$initial_identityfile"; then
        return # User cancelled
    fi

    # --- Save Logic ---
    if [[ -z "$new_alias" || -z "$new_hostname" ]]; then printErrMsg "Host Alias and HostName cannot be empty."; sleep 2; return 1; fi
    if get_ssh_hosts | grep -qFx "$new_alias"; then printErrMsg "Host alias '${new_alias}' already exists."; sleep 2; return 1; fi

    _append_host_to_config "$new_alias" "$new_hostname" "$new_user" "$new_port" "$new_identityfile"

    if [[ -n "$new_identityfile" ]]; then
        # When creating from scratch, it's more likely the user wants to copy the key immediately.
        if prompt_yes_no "Copy public key to the new server now?" "y"; then copy_ssh_id_for_host "$new_alias" "${new_identityfile}.pub"; fi
    fi
    if prompt_yes_no "Test the connection to '${new_alias}' now?" "y"; then echo; _test_connection_for_host "$new_alias"; fi
}

# Prompts user for details and adds a new host to the SSH config.
# This version is for the command-line flag and presents the initial choice.
add_ssh_host() {
    printBanner "Add New SSH Host"

    # --- Step 1: Choose to create from scratch or clone ---
    local -a add_options=("Create a new host from scratch" "Clone settings from an existing host")
    local add_choice_idx
    add_choice_idx=$(interactive_single_select_menu "How would you like to add the new host?" "" "${add_options[@]}")
    if [[ $? -ne 0 ]]; then printInfoMsg "Host creation cancelled."; return; fi

    # --- Step 2: Handle choice ---
    if [[ "${add_options[$add_choice_idx]}" == "Clone settings from an existing host" ]]; then
        # Delegate to the dedicated clone function.
        # shellcheck disable=SC2119
        clone_ssh_host
        return
    fi

    # --- Create from scratch logic ---
    # This function is now separate, call it.
    add_ssh_host_from_scratch
}

# (Private) A generic, reusable interactive loop for the host editors.
# This function encapsulates the shared UI loop for adding, editing, and cloning hosts,
# significantly reducing code duplication.
#
# It modifies the 'new_*' variables in the caller's scope via namerefs.
#
# Usage: _interactive_host_editor_loop <mode> <banner> <n_alias_var> ... <o_alias> ...
# Returns 0 if the user chooses to save, 1 if they cancel/quit.
_interactive_host_editor_loop() {
    local mode="$1"
    local banner_text="$2"
    # These are the *names* of the variables in the caller's scope.
    local p_alias="$3" p_hostname="$4" p_user="$5" p_port="$6" p_identityfile="$7"
    # Use namerefs internally for easier access to the values.
    local -n n_alias="$p_alias" n_hostname="$p_hostname" n_user="$p_user" n_port="$p_port" n_identityfile="$p_identityfile"
    # Original values are passed by value for comparison.
    local original_alias="$8" original_hostname="$9" original_user="${10}" original_port="${11}" original_identityfile="${12}"

    # Initial draw
    clear
    printBanner "$banner_text"
    _draw_interactive_host_editor_ui "$mode" "$n_alias" "$n_hostname" "$n_user" "$n_port" "$n_identityfile" \
                                     "$original_alias" "$original_hostname" "$original_user" "$original_port" "$original_identityfile"

    while true; do
        local key; key=$(read_single_char)
        # Default to redrawing after any action, except for ignored keys.
        local needs_redraw=true

        case "$key" in
            '1')
                # Edit Alias
                local prompt="Enter a short alias for the host"
                local old_alias_to_allow=""
                if [[ "$mode" == "edit" ]]; then prompt="Enter the new alias for the host"; old_alias_to_allow="$original_alias"; fi
                if [[ "$mode" == "clone" ]]; then prompt="Enter the new alias for the cloned host"; fi
                _prompt_for_unique_host_alias "$p_alias" "$prompt" "$old_alias_to_allow" "$n_alias"
                ;;
            '2') prompt_for_input "HostName" "$p_hostname" "$n_hostname" ;;
            '3') prompt_for_input "User" "$p_user" "$n_user" ;;
            '4') prompt_for_input "Port" "$p_port" "$n_port" ;;
            '5') clear_current_line; _prompt_for_identity_file_interactive "$p_identityfile" "$n_identityfile" "$n_alias" "$n_user" "$n_hostname" ;;
            'c'|'C'|'d'|'D')
                # Discard/Reset
                clear_current_line
                local question="Discard all pending changes?"
                if [[ "$mode" == "add" ]]; then question="Discard all changes and reset fields?"; fi
                if prompt_yes_no "$question" "y"; then
                    n_alias="$original_alias"; n_hostname="$original_hostname"; n_user="$original_user"; n_port="$original_port"; n_identityfile="$original_identityfile"
                    printInfoMsg "Changes discarded."; sleep 1
                fi
                ;;
            's'|'S') return 0 ;; # Signal to Save
            'q'|'Q'|"$KEY_ESC")
                # Quit
                local expanded_new_idfile="${n_identityfile/#\~/$HOME}"; local expanded_orig_idfile="${original_identityfile/#\~/$HOME}"
                if [[ "$n_alias" != "$original_alias" || "$n_hostname" != "$original_hostname" || "$n_user" != "$original_user" || "$n_port" != "$original_port" || "$expanded_new_idfile" != "$expanded_orig_idfile" ]]; then
                    clear_current_line
                    if prompt_yes_no "You have unsaved changes. Quit without saving?" "n"; then
                        printInfoMsg "Operation cancelled."; sleep 1; return 1
                    fi
                else
                    return 1 # No changes, just quit
                fi
                ;;
            *)
                # Any other key is ignored and does not trigger a redraw.
                needs_redraw=false
                ;;
        esac

        # Redraw the screen if any action that might have changed data or dirtied the screen was taken.
        if [[ "$needs_redraw" == "true" ]]; then
            clear
            printBanner "$banner_text"
            _draw_interactive_host_editor_ui "$mode" "$n_alias" "$n_hostname" "$n_user" "$n_port" "$n_identityfile" \
                                             "$original_alias" "$original_hostname" "$original_user" "$original_port" "$original_identityfile"
        fi
    done
}

# (Private) Helper function to copy both private and public key files.
# This is designed to be called by `run_with_spinner`.
# Usage: _copy_key_pair <source_base_path> <dest_base_path>
_copy_key_pair() {
    local source_base="$1"
    local dest_base="$2"
    cp "${source_base}" "${dest_base}" && cp "${source_base}.pub" "${dest_base}.pub"
}

# Edits an existing host in the SSH config.
edit_ssh_host() {
    printBanner "Edit SSH Host"

    local original_alias="$1"
    if [[ -z "$original_alias" ]]; then
        original_alias=$(select_ssh_host "Select a host to edit:")
        [[ $? -ne 0 ]] && return
    fi

    # Get original values to compare against for changes.
    local original_hostname original_user original_port original_identityfile
    local details; details=$(_get_all_ssh_config_values_as_string "$original_alias")
    # Use parameter expansion to rename the 'current_*' variables from the helper to 'original_*'.
    eval "${details//current/original}" # Sets original_hostname, original_user, original_port
    original_identityfile=$(_get_explicit_ssh_config_value "$original_alias" "IdentityFile")
    [[ -z "$original_port" ]] && original_port="22"

    # These variables will hold the values as they are being edited.
    local new_alias="$original_alias" new_hostname="$original_hostname" new_user="$original_user" new_port="$original_port" new_identityfile="$original_identityfile"

    local banner_text="Edit SSH Host - ${C_L_CYAN}${original_alias}${C_BLUE}"
    if ! _interactive_host_editor_loop "edit" "$banner_text" \
        new_alias new_hostname new_user new_port new_identityfile \
        "$original_alias" "$original_hostname" "$original_user" "$original_port" "$original_identityfile"; then
        return # User cancelled
    fi

    # --- Save Logic ---
    local expanded_new_idfile="${new_identityfile/#\~/$HOME}"; local expanded_orig_idfile="${original_identityfile/#\~/$HOME}"
    if [[ "$new_alias" == "$original_alias" && "$new_hostname" == "$original_hostname" && "$new_user" == "$original_user" && "$new_port" == "$original_port" && "$expanded_new_idfile" == "$expanded_orig_idfile" ]]; then
        printInfoMsg "No changes detected. Host configuration remains unchanged."; sleep 1; return
    fi

    # --- Handle Key Management if Alias Changed ---
    if [[ "$new_alias" != "$original_alias" && -n "$new_identityfile" ]]; then
        # This function will prompt the user and may update `new_identityfile`.
        if ! _handle_key_management_on_alias_change new_identityfile "$original_alias" "$new_alias" "$new_identityfile"; then
            printErrMsg "Host update aborted due to key management failure."; sleep 2
            return 1
        fi
    fi

    local config_without_host; config_without_host=$(_remove_host_block_from_config "$original_alias")
    local new_host_block; new_host_block=$(_build_host_block_string "$new_alias" "$new_hostname" "$new_user" "$new_port" "$new_identityfile")
    printf '%s\n\n%s' "$config_without_host" "$new_host_block" | cat -s > "$SSH_CONFIG_PATH"
    printOkMsg "Host '${original_alias}' has been updated to '${new_alias}'."

    if [[ -n "$original_identityfile" && "$expanded_new_idfile" != "$expanded_orig_idfile" ]]; then
        _cleanup_orphaned_key "$original_identityfile"
    fi
}

# (Private) Handles renaming or copying a key file when a host's alias is changed.
# If the key is shared, it offers to copy. If not, it offers to rename.
# The new key path is returned via a nameref.
# Usage: _handle_key_management_on_alias_change new_identityfile_var "$original_alias" "$new_alias" "$current_identityfile"
# Returns 0 on success, 1 on failure.
_handle_key_management_on_alias_change() {
    local -n out_new_identityfile_ref="$1"
    local original_alias="$2"
    local new_alias="$3"
    local current_identityfile="$4"

    # If no identity file is set, there's nothing to do.
    if [[ -z "$current_identityfile" ]]; then
        return 0
    fi

    local expanded_old_key_path="${current_identityfile/#\~/$HOME}"
    if [[ ! -f "$expanded_old_key_path" ]]; then
        # Key file doesn't exist, so nothing to rename/copy.
        return 0
    fi

    # Find if other hosts share this key.
    local -a hosts_sharing_key=()
    mapfile -t all_hosts < <(get_ssh_hosts)
    for other_host in "${all_hosts[@]}"; do
        if [[ "$other_host" != "$original_alias" ]]; then
            local other_host_key; other_host_key=$(_get_explicit_ssh_config_value "$other_host" "IdentityFile")
            if [[ "$other_host_key" == "$current_identityfile" ]]; then
                hosts_sharing_key+=("$other_host")
            fi
        fi
    done

    # Propose a new key name based on the new host alias (convention).
    local proposed_new_key_path="${SSH_DIR}/${new_alias}_id_ed25519"

    if [[ ${#hosts_sharing_key[@]} -gt 0 ]]; then
        # Key is shared, offer to COPY it.
        local question="The key '${current_identityfile/#$HOME/\~}' is shared by other hosts.\n    Do you want to create a dedicated COPY of this key for '${new_alias}'?\n    New key path: ${C_L_BLUE}${proposed_new_key_path/#$HOME/\~}${T_RESET}"
        if prompt_yes_no "$question" "y"; then
            if [[ -f "$proposed_new_key_path" || -f "${proposed_new_key_path}.pub" ]]; then printErrMsg "Cannot create key copy: target file '${proposed_new_key_path/#$HOME/\~}' or its .pub already exists."; return 1; fi
            if run_with_spinner "Copying key files..." _copy_key_pair "$expanded_old_key_path" "$proposed_new_key_path"; then
                out_new_identityfile_ref="$proposed_new_key_path" # Update the nameref to point to the new key path.
            else printErrMsg "Failed to copy key files."; return 1; fi
        fi
    elif [[ "$expanded_old_key_path" != "$proposed_new_key_path" ]]; then
        # Key is not shared, offer to RENAME it.
        local question="This host uses the key:\n    ${C_L_BLUE}${current_identityfile/#$HOME/\~}${T_RESET}\nDo you want to rename this key to match the new host alias?\n    New name: ${C_L_BLUE}${proposed_new_key_path/#$HOME/\~}${T_RESET}"
        if prompt_yes_no "$question" "y"; then
            if [[ -f "$proposed_new_key_path" || -f "${proposed_new_key_path}.pub" ]]; then printErrMsg "Cannot rename key: target file '${proposed_new_key_path/#$HOME/\~}' or its .pub already exists."; return 1; fi
            if run_with_spinner "Renaming key files..." _rename_key_pair "$expanded_old_key_path" "$proposed_new_key_path"; then
                out_new_identityfile_ref="$proposed_new_key_path" # Update the nameref to point to the new key path.
            else printErrMsg "Failed to rename key files."; return 1; fi
        fi
    fi
    return 0
}


# Allows advanced editing of a host's config block directly in $EDITOR.
edit_ssh_host_in_editor() {
    printBanner "Edit Host Block in Editor"

    local host_to_edit="$1"
    if [[ -z "$host_to_edit" ]]; then
        host_to_edit=$(select_ssh_host "Select a host to edit:")
        [[ $? -ne 0 ]] && return # select_ssh_host prints messages
    fi

    # Get the original block content
    local original_block
    original_block=$(_get_host_block_from_config "$host_to_edit" "$SSH_CONFIG_PATH")

    if [[ -z "$original_block" ]]; then
        printErrMsg "Could not find a configuration block for '${host_to_edit}'."
        return 1
    fi

    # Create a temporary file to hold the block for editing
    local temp_file
    # Use a suffix that editors like Vim/Neovim will recognize for ssh_config syntax highlighting.
    temp_file=$(mktemp --suffix=.sshconfig)
    # Ensure temp file is cleaned up on exit or interrupt
    trap 'rm -f "$temp_file"' RETURN

    # Add a Vim/Neovim modeline to the top of the temp file to explicitly set the filetype.
    # This is more reliable than relying on just the filename extension.
    # The modeline will be stripped out before saving.
    echo "# vim: set filetype=sshconfig:" > "$temp_file"
    echo "$original_block" >> "$temp_file"

    # Determine the editor to use
    local editor="${EDITOR:-nvim}"
    if ! command -v "${editor}" &>/dev/null; then
        printErrMsg "Editor '${editor}' not found. Please set the EDITOR environment variable."
        return 1
    fi

    printInfoMsg "Opening '${host_to_edit}' in '${editor}'..."
    printInfoMsg "(Save and close the editor to apply changes,\n    or exit without saving to cancel)"
    # Give the user a moment to read the message before launching the editor.
    prompt_to_continue

    # clear out the instructions
    clear_lines_up 3
    # Open the temp file in the editor. This is a blocking call.
    "${editor}" "$temp_file"

    # Read the potentially modified content
    local new_block
    # Strip the modeline we added. The rest is the user's content.
    new_block=$(grep -v "vim: set filetype=sshconfig:" "$temp_file")

    # Command substitution `$(...)` strips trailing newlines from both original_block and new_block,
    # making them directly comparable if no changes were made.
    if [[ "$new_block" == "$original_block" ]]; then
        printInfoMsg "No changes detected. Configuration for '${host_to_edit}' remains unchanged."
        return
    fi

    # Get the config content without the old host block and append the new one
    local config_without_host
    config_without_host=$(_remove_host_block_from_config "$host_to_edit")
    printf '%s\n\n%s' "$config_without_host" "$new_block" | cat -s > "$SSH_CONFIG_PATH"

    printOkMsg "Host '${host_to_edit}' has been updated from editor."
}

# Clones an existing SSH host configuration to a new alias using an interactive UI.
# shellcheck disable=SC2120
clone_ssh_host() {
    local host_to_clone="$1"
    if [[ -z "$host_to_clone" ]]; then
        printBanner "Clone SSH Host"
        host_to_clone=$(select_ssh_host "Select a host to clone:")
        [[ $? -ne 0 ]] && return # select_ssh_host prints messages
    fi

    # Get original values from the source host.
    local original_hostname original_user original_port original_identityfile
    local details; details=$(_get_all_ssh_config_values_as_string "$host_to_clone")
    eval "${details//current/original}" # Sets original_hostname, original_user, original_port
    original_identityfile=$(_get_explicit_ssh_config_value "$host_to_clone" "IdentityFile")
    [[ -z "$original_port" ]] && original_port="22"

    # These variables will hold the values for the new cloned host.
    local new_hostname="$original_hostname" new_user="$original_user" new_port="$original_port" new_identityfile="$original_identityfile"
    # Propose a unique new alias.
    local new_alias i=1
    while true; do
        local proposed_alias="${host_to_clone}-clone"; [[ $i -gt 1 ]] && proposed_alias+="-${i}"
        if ! get_ssh_hosts | grep -qFx "$proposed_alias"; then new_alias="$proposed_alias"; break; fi
        ((i++))
    done

    local banner_text="Clone Host from ${C_L_CYAN}${host_to_clone}${C_BLUE}"
    if ! _interactive_host_editor_loop "clone" "$banner_text" \
        new_alias new_hostname new_user new_port new_identityfile \
        "$new_alias" "$original_hostname" "$original_user" "$original_port" "$original_identityfile"; then
        return # User cancelled
    fi

    # --- Save Logic ---
    if get_ssh_hosts | grep -qFx "$new_alias"; then printErrMsg "Host alias '${new_alias}' already exists."; sleep 2; return 1; fi

    _append_host_to_config "$new_alias" "$new_hostname" "$new_user" "$new_port" "$new_identityfile"

    if [[ -n "$new_identityfile" ]] && prompt_yes_no "Copy public key to the new server now?" "n"; then
        copy_ssh_id_for_host "$new_alias" "${new_identityfile}.pub"
    fi

    if prompt_yes_no "Test the connection to '${new_alias}' now?" "y"; then
        echo; _test_connection_for_host "$new_alias"
    fi
}

# (Private) Checks for and offers to remove an orphaned key file.
# An orphaned key is one that is no longer referenced by any host in the SSH config.
# This is typically called after a host has been removed from the config.
# Usage: _cleanup_orphaned_key <path_to_key_file>
_cleanup_orphaned_key() {
    local key_file_path="$1"

    # 1. If no key file was associated with the host, there's nothing to do.
    if [[ -z "$key_file_path" ]]; then
        return
    fi

    # 2. Expand tilde to full path for checks.
    local expanded_key_path="${key_file_path/#\~/$HOME}"

    # 3. Check if the key file actually exists.
    if [[ ! -f "$expanded_key_path" ]]; then
        return
    fi

    # 4. Check if any other host in the *current* config uses this key.
    mapfile -t remaining_hosts < <(get_ssh_hosts)
    for host in "${remaining_hosts[@]}"; do
        local host_key_file; host_key_file=$(get_ssh_config_value "$host" "IdentityFile")
        local expanded_host_key_file="${host_key_file/#\~/$HOME}"

        if [[ "$expanded_host_key_file" == "$expanded_key_path" ]]; then
            printInfoMsg "The key '${key_file_path/#$HOME/\~}' is still in use by host '${host}'. It will not be removed."
            return # Key is in use, so we're done.
        fi
    done

    # 5. If we get here, the key is not used by any other host. Prompt for deletion.
    if prompt_yes_no "The key '${key_file_path/#$HOME/\~}' is no longer referenced by any host.\n    Remove it and its .pub file?" "n"; then
        rm -f "${expanded_key_path}" "${expanded_key_path}.pub"
        printOkMsg "Removed key files."
    fi
}

# Removes a host entry from the SSH config file.
remove_ssh_host() {
    printBanner "Remove SSH Host"

    local host_to_remove="$1"
    if [[ -z "$host_to_remove" ]]; then
        host_to_remove=$(select_ssh_host "Select a host to remove:")
        [[ $? -ne 0 ]] && return
    fi

    if ! prompt_yes_no "Are you sure you want to remove '${host_to_remove}'?\n    This will permanently delete the host from your config." "n"; then
        printInfoMsg "Removal cancelled."
        return
    fi

    # Get the IdentityFile path *before* removing the host from the config.
    local identity_file_to_check
    identity_file_to_check=$(_get_explicit_ssh_config_value "$host_to_remove" "IdentityFile")

    # Get the config content without the specified host block
    local new_config_content
    new_config_content=$(_remove_host_block_from_config "$host_to_remove")

    # Overwrite the config file with the new content, squeezing blank lines
    echo "$new_config_content" | cat -s > "$SSH_CONFIG_PATH"

    printOkMsg "Host '${host_to_remove}' has been removed."

    # Pass the actual key file path to the cleanup function.
    _cleanup_orphaned_key "$identity_file_to_check"
}

# (Private) Helper to test connection to a specific host using BatchMode.
# Usage: _test_connection_for_host <host_alias>
_test_connection_for_host() {
    local host_to_test="$1"
    # -o BatchMode=yes: Never ask for passwords.
    # -o ConnectTimeout=5: A shorter timeout is better for quick tests.
    # 'exit' is a simple command that immediately closes the connection upon success.
    if run_with_spinner "Testing connection to '${host_to_test}'..." \
        ssh -o BatchMode=yes -o ConnectTimeout=5 "${host_to_test}" 'exit'
    then
        # remove the spinner output to reduce visual clutter
        clear_lines_up 1
        printOkMsg "Connection to '${host_to_test}' was ${BG_GREEN}${C_BLACK} successful ${T_RESET}"
        return 0
    else
        # run_with_spinner prints the error details from ssh
        printInfoMsg "Check your SSH config, network, firewall rules, and ensure your public key is on the server."
        return 1
    fi
}

# Tests the SSH connection to a selected server.
test_ssh_connection() {
    printBanner "Test SSH Connection"

    local host_to_test
    host_to_test=$(select_ssh_host "Select a host to test:")
    [[ $? -ne 0 ]] && return

    _test_connection_for_host "$host_to_test"
}

# (Private) The actual test logic for a single host, run in the background.
# It writes its result to a file in a temporary directory.
# Usage: _test_single_host_in_background <host> <result_dir>
_test_single_host_in_background() {
    local host_to_test="$1"
    local result_dir="$2"
    # The result file is named after the host, with slashes replaced to be safe.
    local result_file="${result_dir}/${host_to_test//\//_}"
 
    # Run ssh only ONCE, capturing stderr and checking the exit code.
    # This is much faster for failed connections than running it twice.
    # A shorter timeout (5s) is used to speed up the "all hosts" test.
    local error_output
    if error_output=$(ssh -o BatchMode=yes -o ConnectTimeout=5 "${host_to_test}" 'exit' 2>&1); then
        echo "success" > "$result_file"
    else
        # If the command failed but produced no output (e.g., timeout), provide a generic message.
        if [[ -z "$error_output" ]]; then
            echo "Connection timed out or failed without error message." > "$result_file"
        else
            echo "$error_output" > "$result_file"
        fi
    fi
}

# Tests all configured SSH hosts in parallel.
test_all_ssh_connections() {
    printBanner "Test All SSH Connections"

    mapfile -t hosts < <(get_ssh_hosts)
    if [[ ${#hosts[@]} -eq 0 ]]; then
        printInfoMsg "No hosts found in your SSH config file to test."
        return
    fi

    local result_dir
    result_dir=$(mktemp -d)
    # Ensure temp directory is cleaned up on exit or interrupt.
    trap 'rm -rf "$result_dir"' RETURN INT TERM

    local -a pids
    printInfoMsg "Starting tests for ${#hosts[@]} hosts in parallel..."
    for host in "${hosts[@]}"; do
        # Run the test for each host in the background.
        _test_single_host_in_background "$host" "$result_dir" &
        pids+=($!)
    done

    # Wait for all background jobs to complete, with a spinner.
    wait_for_pids_with_spinner "Running all connection tests" "${pids[@]}"

    # --- Print Summary ---
    printMsg "\n${T_ULINE}Test Results:${T_RESET}"
    local success_count=0
    local failure_count=0

    for host in "${hosts[@]}"; do
        local result_file="${result_dir}/${host//\//_}"
        local result
        result=$(<"$result_file")

        if [[ "$result" == "success" ]]; then
            ((success_count++))
            printOkMsg "Connection to '${host}' was ${BG_GREEN}${C_BLACK} successful ${T_RESET}"
        else
            ((failure_count++))
            printErrMsg "${host}"
            # Indent the error message for readability.
            while IFS= read -r line; do
                printMsg "    ${C_GRAY}${line}${T_RESET}"
            done <<< "$result"
        fi
    done

    # Final summary line
    echo
    local summary_msg
    if (( failure_count > 0 )); then
        summary_msg="Summary: ${C_L_GREEN}${success_count} successful${T_RESET}, ${C_L_RED}${failure_count} failed${T_RESET}."
        printErrMsg "$summary_msg"
    else
        summary_msg="Summary: ${C_L_GREEN}${success_count} successful${T_RESET}, ${C_GRAY}${failure_count} failed${T_RESET}."
        printOkMsg "$summary_msg"
    fi
}

# (Private) Reads saved port forwards from the config file.
# Populates arrays with their details.
# Usage: _get_saved_port_forwards types_array specs_array hosts_array descs_array
_get_saved_port_forwards() {
    local -n out_types="$1" out_specs="$2" out_hosts="$3" out_descs="$4"
    out_types=() out_specs=() out_hosts=() out_descs=()
    if [[ ! -f "$PORT_FORWARDS_CONFIG_PATH" ]]; then return 1; fi
    while IFS='|' read -r type spec host desc || [[ -n "$type" ]]; do
        [[ -z "$type" || "$type" =~ ^# ]] && continue
        out_types+=("$type"); out_specs+=("$spec"); out_hosts+=("$host"); out_descs+=("$desc")
    done < "$PORT_FORWARDS_CONFIG_PATH"
}

# (Private) Writes an array of port forward configurations to the file, overwriting it.
# Usage: _save_all_port_forwards types_array specs_array hosts_array descs_array
_save_all_port_forwards() {
    # Use ref_ prefix for namerefs to avoid circular reference if caller uses same variable names.
    local -n ref_types="$1" ref_specs="$2" ref_hosts="$3" ref_descs="$4"
    local temp_file; temp_file=$(mktemp)
    for i in "${!ref_types[@]}"; do echo "${ref_types[i]}|${ref_specs[i]}|${ref_hosts[i]}|${ref_descs[i]}" >> "$temp_file"; done
    mv "$temp_file" "$PORT_FORWARDS_CONFIG_PATH"
}

# Adds a new port forward configuration to the saved list.
add_saved_port_forward() {
    printBanner "Add New Saved Port Forward"

    # Set up initial empty/default values for the new forward.
    local original_type="Local" original_p1="8080" original_h="localhost" original_p2="80" original_host="" original_desc=""

    # These variables will be modified by the editor loop.
    local new_type="$original_type" new_p1="$original_p1" new_h="$original_h" new_p2="$original_p2" new_host="$original_host" new_desc="$original_desc"

    local banner_text="Add New Saved Port Forward"
    if ! _interactive_port_forward_editor_loop "add" "$banner_text" \
        new_type new_p1 new_h new_p2 new_host new_desc \
        "$original_type" "$original_p1" "$original_h" "$original_p2" "$original_host" "$original_desc"; then
        printInfoMsg "Add cancelled. No changes were saved."
        return
    fi

    # --- Save Logic ---
    if [[ -z "$new_host" || -z "$new_p1" || -z "$new_h" || -z "$new_p2" ]]; then
        printErrMsg "Host and all port/host specifiers are required."; sleep 2; return 1
    fi

    local new_spec="${new_p1}:${new_h}:${new_p2}"
    if [[ -z "$new_desc" ]]; then new_desc="${new_spec} on ${new_host}"; fi

    local -a all_types all_specs all_hosts all_descs; _get_saved_port_forwards all_types all_specs all_hosts all_descs
    all_types+=("$new_type"); all_specs+=("$new_spec"); all_hosts+=("$new_host"); all_descs+=("$new_desc")
    _save_all_port_forwards all_types all_specs all_hosts all_descs
    printOkMsg "Saved new port forward: ${new_desc}"
}

# (Private) A generic, reusable interactive loop for the port forward editors.
# This function encapsulates the shared UI loop for editing and cloning forwards.
#
# It modifies variables in the caller's scope via namerefs.
#
# Usage: _interactive_port_forward_editor_loop <banner> <p_type> <p_p1> <p_h> <p_p2> <p_host> <p_desc>
# Returns 0 if the user chooses to save, 1 if they cancel/quit.
_draw_interactive_port_forward_editor_ui() {
    local mode="$1"
    local new_type="$2" new_p1="$3" new_h="$4" new_p2="$5" new_host="$6" new_desc="$7"
    local original_type="$8" original_p1="$9" original_h="${10}" original_p2="${11}" original_host="${12}" original_desc="${13}"

    # Helper to format a line, adding a change indicator (*) if needed.
    _format_line() {
        local key="$1" label="$2" new_val="$3" original_val="$4"

        local display_val="${new_val}"; if [[ -z "$display_val" ]]; then display_val="${C_GRAY}(not set)${T_RESET}"; else display_val="${C_L_CYAN}${display_val}${T_RESET}"; fi

        local change_indicator=" "
        if [[ "$mode" != "add" ]]; then
            if [[ "$new_val" != "$original_val" ]]; then change_indicator="${C_L_YELLOW}*${T_RESET}"; fi
        fi

        printf "  ${C_L_WHITE}%s)${T_RESET} %b %-15s: %b\n" "$key" "$change_indicator" "$label" "$display_val"
    }

    local p1_label="Local Port" h_label="Remote Host" p2_label="Remote Port"
    if [[ "$new_type" == "Remote" ]]; then
        p1_label="Remote Port" h_label="Local Host" p2_label="Local Port"
    fi

    printMsg "Choose an option to configure:"
    _format_line "1" "Type" "$new_type" "$original_type"
    _format_line "2" "SSH Host" "$new_host" "$original_host"
    _format_line "3" "${p1_label}" "$new_p1" "$original_p1"
    _format_line "4" "${h_label}" "$new_h" "$original_h"
    _format_line "5" "${p2_label}" "$new_p2" "$original_p2"
    _format_line "6" "Description" "$new_desc" "$original_desc"

    echo
    printMsg "  ${C_L_WHITE}c) ${C_L_YELLOW}(C)ancel/(D)iscard${T_RESET} all pending changes"
    printMsg "  ${C_L_WHITE}s) ${C_L_GREEN}(S)ave${T_RESET} and Quit"
    printMsg "  ${C_L_WHITE}q) ${C_L_YELLOW}(Q)uit${T_RESET} without saving (or press ${C_L_YELLOW}ESC${T_RESET})"
    echo
    printMsgNoNewline "${T_QST_ICON} Your choice: "
}

_interactive_port_forward_editor_loop() {
    local mode="$1"
    local banner_text="$2"
    # These are the *names* of the variables in the caller's scope.
    local p_type="$3" p_p1="$4" p_h="$5" p_p2="$6" p_host="$7" p_desc="$8"
    # Use namerefs internally for easier access to the values.
    local -n n_type="$p_type" n_p1="$p_p1" n_h="$p_h" n_p2="$p_p2" n_host="$p_host" n_desc="$p_desc"
    # Original values are passed by value for comparison.
    local original_type="$9" original_p1="${10}" original_h="${11}" original_p2="${12}" original_host="${13}" original_desc="${14}"

    # Initial draw
    clear
    printBanner "$banner_text"
    _draw_interactive_port_forward_editor_ui "$mode" "$n_type" "$n_p1" "$n_h" "$n_p2" "$n_host" "$n_desc" \
                                             "$original_type" "$original_p1" "$original_h" "$original_p2" "$original_host" "$original_desc"

    while true; do
        local key; key=$(read_single_char)
        # Default to redrawing after any action, except for ignored keys.
        local needs_redraw=true

        case "$key" in
            '1')
                # Edit Type
                clear_current_line
                local -a type_options=("Local (-L)" "Remote (-R)"); local type_idx
                type_idx=$(interactive_single_select_menu "Select forward type:" "" "${type_options[@]}")
                if [[ $? -eq 0 ]]; then if [[ "$type_idx" -eq 0 ]]; then n_type="Local"; else n_type="Remote"; fi; fi
                ;;
            '2')
                # Edit SSH Host
                clear_current_line
                local selected_host; selected_host=$(select_ssh_host "Select a new SSH host:" "false")
                if [[ $? -eq 0 ]]; then n_host="$selected_host"; fi
                ;;
            '3')
                # Edit Port 1
                clear_current_line
                local p1_label="Local Port"; if [[ "$n_type" == "Remote" ]]; then p1_label="Remote Port"; fi
                prompt_for_input "Enter the ${p1_label} to listen on" "$p_p1" "$n_p1"
                ;;
            '4')
                # Edit Host
                clear_current_line
                local h_prompt="Enter the REMOTE host to connect to (from ${n_host})"; if [[ "$n_type" == "Remote" ]]; then h_prompt="Enter the LOCAL host to connect to"; fi
                prompt_for_input "$h_prompt" "$p_h" "$n_h"
                ;;
            '5')
                # Edit Port 2
                clear_current_line
                local p2_prompt="Enter the REMOTE port to connect to"; if [[ "$n_type" == "Remote" ]]; then p2_prompt="Enter the LOCAL port to connect to"; fi
                prompt_for_input "$p2_prompt" "$p_p2" "$n_p2"
                ;;
            '6')
                # Edit Description
                prompt_for_input "Enter a short description" "$p_desc" "$n_desc"
                ;;
            'c'|'C'|'d'|'D')
                # Discard
                clear_current_line
                local question="Discard all pending changes?"; if [[ "$mode" == "add" || "$mode" == "clone" ]]; then question="Discard all changes and reset fields?"; fi
                if prompt_yes_no "$question" "y"; then
                    n_type="$original_type"; n_p1="$original_p1"; n_h="$original_h"; n_p2="$original_p2"; n_host="$original_host"; n_desc="$original_desc"
                    printInfoMsg "Changes discarded."; sleep 1
                fi
                ;;
            's'|'S') return 0 ;; # Signal to Save
            'q'|'Q'|"$KEY_ESC")
                # Quit
                if [[ "$n_type" != "$original_type" || "$n_p1" != "$original_p1" || "$n_h" != "$original_h" || "$n_p2" != "$original_p2" || "$n_host" != "$original_host" || "$n_desc" != "$original_desc" ]]; then
                    clear_current_line
                    if prompt_yes_no "You have unsaved changes. Quit without saving?" "n"; then printInfoMsg "Operation cancelled."; sleep 1; return 1; fi
                else return 1; fi
                ;;
            *)
                # Any other key is ignored and does not trigger a redraw.
                needs_redraw=false
                ;;
        esac

        # Redraw the screen if any action that might have changed data or dirtied the screen was taken.
        if [[ "$needs_redraw" == "true" ]]; then
            clear
            printBanner "$banner_text"
            _draw_interactive_port_forward_editor_ui "$mode" "$n_type" "$n_p1" "$n_h" "$n_p2" "$n_host" "$n_desc" \
                                                     "$original_type" "$original_p1" "$original_h" "$original_p2" "$original_host" "$original_desc"
        fi
    done
}

# Edits a saved port forward configuration.
edit_saved_port_forward() {
    local idx_to_edit="$1"
    local -a all_types all_specs all_hosts all_descs; _get_saved_port_forwards all_types all_specs all_hosts all_descs
    local original_type="${all_types[$idx_to_edit]}" original_spec="${all_specs[$idx_to_edit]}" original_host="${all_hosts[$idx_to_edit]}" original_desc="${all_descs[$idx_to_edit]}"

    # Deconstruct spec for editing
    local original_p1="${original_spec%%:*}"; local remote_part="${original_spec#*:}"
    local original_h="${remote_part%:*}"; local original_p2="${remote_part##*:}"

    # Set up variables for the editor loop
    local new_type="$original_type" new_host="$original_host" new_desc="$original_desc"
    local new_p1="$original_p1" new_h="$original_h" new_p2="$original_p2"

    local banner_text="Edit Saved Port Forward - ${C_L_CYAN}${original_desc}${C_BLUE}"
    if ! _interactive_port_forward_editor_loop "edit" "$banner_text" \
        new_type new_p1 new_h new_p2 new_host new_desc \
        "$original_type" "$original_p1" "$original_h" "$original_p2" "$original_host" "$original_desc"; then
        printInfoMsg "Edit cancelled. No changes were saved."
        return
    fi

    local new_spec="${new_p1}:${new_h}:${new_p2}"
    if [[ "$new_type" == "$original_type" && "$new_spec" == "$original_spec" && "$new_host" == "$original_host" && "$new_desc" == "$original_desc" ]]; then
        printInfoMsg "No changes detected. Configuration remains unchanged."
        return
    fi

    all_types[$idx_to_edit]="$new_type"
    all_specs[$idx_to_edit]="$new_spec"
    all_hosts[$idx_to_edit]="$new_host"
    all_descs[$idx_to_edit]="$new_desc"
    _save_all_port_forwards all_types all_specs all_hosts all_descs
    printOkMsg "Saved port forward has been updated."
}

# Deletes a saved port forward configuration.
delete_saved_port_forward() {
    local idx_to_delete="$1" type="$2" spec="$3" host="$4"
    if ! prompt_yes_no "Permanently delete saved forward '${spec}' on '${host}'?" "n"; then printInfoMsg "Deletion cancelled."; return; fi
    local -a all_types all_specs all_hosts all_descs; _get_saved_port_forwards all_types all_specs all_hosts all_descs
    local -a new_types new_specs new_hosts new_descs
    for i in "${!all_types[@]}"; do
        if [[ "$i" -ne "$idx_to_delete" ]]; then
            new_types+=("${all_types[i]}"); new_specs+=("${all_specs[i]}"); new_hosts+=("${all_hosts[i]}"); new_descs+=("${all_descs[i]}")
        fi
    done
    _save_all_port_forwards new_types new_specs new_hosts new_descs
    printOkMsg "Deleted saved port forward."
}

# Clones a saved port forward configuration.
clone_saved_port_forward() {
    local type_to_clone="$1" spec_to_clone="$2" host_to_clone="$3" desc_to_clone="$4"

    # Deconstruct spec for editing
    local original_p1="${spec_to_clone%%:*}"; local remote_part="${spec_to_clone#*:}"
    local original_h="${remote_part%:*}"; local original_p2="${remote_part##*:}"

    # Set up initial values for the new cloned forward
    local new_type="$type_to_clone" new_host="$host_to_clone" new_desc="Clone of ${desc_to_clone}"
    local new_p1=$((original_p1 + 1)) new_h="$original_h" new_p2="$original_p2"

    local banner_text="Clone Saved Port Forward - from ${C_L_CYAN}${desc_to_clone}${C_BLUE}"
    if ! _interactive_port_forward_editor_loop "clone" "$banner_text" \
        new_type new_p1 new_h new_p2 new_host new_desc \
        "$type_to_clone" "$original_p1" "$original_h" "$original_p2" "$host_to_clone" "$desc_to_clone"; then
        printInfoMsg "Clone cancelled. No changes were saved."
        return
    fi

    local new_spec="${new_p1}:${new_h}:${new_p2}"
    local -a all_types all_specs all_hosts all_descs; _get_saved_port_forwards all_types all_specs all_hosts all_descs
    all_types+=("$new_type"); all_specs+=("$new_spec"); all_hosts+=("$new_host"); all_descs+=("$new_desc")
    _save_all_port_forwards all_types all_specs all_hosts all_descs
    printOkMsg "Saved cloned port forward."
}

# Activates a saved port forward by running ssh in the background.
activate_port_forward() {
    local type="$1" spec="$2" host="$3"
    local flag; if [[ "$type" == "Local" ]]; then flag="-L"; else flag="-R"; fi
    local -a cmd_array=("ssh" "-o" "ExitOnForwardFailure=yes" "-N" "-f" "${flag}" "${spec}" "${host}")
    printInfoMsg "Activating forward: ${type} ${spec} on ${host}"
    printMsg "  ${C_L_BLUE}${cmd_array[*]}${T_RESET}"
    if run_with_spinner "Establishing port forward..." "${cmd_array[@]}"; then
        printOkMsg "Port forward activated in the background."
    else
        printErrMsg "Failed to activate port forward."
    fi
}

# Deactivates a port forward by killing its process.
deactivate_port_forward() {
    local pid="$1" spec="$2" host="$3"
    if ! prompt_yes_no "Stop port forward ${spec} on ${host} (PID: ${pid})?" "y"; then printInfoMsg "Operation cancelled."; return; fi
    if run_with_spinner "Stopping port forward (PID: ${pid})..." kill "$pid"; then
        printOkMsg "Port forward stopped."
    else
        printErrMsg "Failed to stop port forward process."
    fi
}

# (Private) Formats a line for displaying port forward information with colors.
# Usage: _format_port_forward_line <pid> <type> <spec> <host>
_format_port_forward_line() {
    local pid="$1"
    local type="$2"
    local spec="$3"
    local host="$4"

    local type_color=""
    if [[ "$type" == "Local" ]]; then
        type_color="$C_L_CYAN"
    elif [[ "$type" == "Remote" ]]; then
        type_color="$C_L_YELLOW"
    fi

    # PID is default, Type is colored, Spec is white, Host is cyan.
    printf "%-10s ${type_color}%-8s ${C_L_WHITE}%-30s ${C_L_CYAN}%s" \
        "$pid" \
        "$type" \
        "$spec" \
        "$host"
}
# (Private) Finds active port forwards and populates arrays with their details.
# Usage: _get_active_port_forwards pids_array types_array specs_array hosts_array
# Returns 0 if forwards are found, 1 otherwise.
_get_active_port_forwards() {
    local -n out_pids="$1"
    local -n out_types="$2"
    local -n out_specs="$3"
    local -n out_hosts="$4"

    # Clear output arrays
    out_pids=()
    out_types=()
    out_specs=()
    out_hosts=()

    local active_forwards
    # Use awk to find processes that are ssh and contain all the necessary flags for a backgrounded port forward.
    # This is more robust than a simple grep, as it is not dependent on the order of arguments (e.g., -o).
    # It looks for 'ssh', '-N', '-f', and either '-L' or '-R'.
    active_forwards=$(ps -eo pid,command | awk '/[s]sh/ && /-N/ && /-f/ && /-[LR]/')

    if [[ -z "$active_forwards" ]]; then
        return 1 # No forwards found
    fi

    while IFS= read -r line; do
        line="${line#"${line%%[![:space:]]*}"}" # Use parameter expansion to trim leading whitespace
        local pid; pid=$(echo "$line" | cut -d' ' -f1)
        local cmd; cmd=$(echo "$line" | cut -d' ' -f2-)
        local type_flag current_spec current_host
        local -a parts=($cmd)
        for i in "${!parts[@]}"; do
            if [[ "${parts[$i]}" == "-L" || "${parts[$i]}" == "-R" ]]; then
                type_flag="${parts[$i]}"; current_spec="${parts[$i+1]}"; break
            fi
        done
        current_host="${parts[-1]}"
        local type_str="Unknown"
        [[ "$type_flag" == "-L" ]] && type_str="Local"
        [[ "$type_flag" == "-R" ]] && type_str="Remote"

        out_pids+=("$pid")
        out_types+=("$type_str")
        out_specs+=("$current_spec")
        out_hosts+=("$current_host")
    done <<< "$active_forwards"

    return 0
}

# Lists all active SSH port forwards found by the script.
list_active_port_forwards() {
    printBanner "Active Port Forwards"

    local -a pids types specs hosts
    if ! _get_active_port_forwards pids types specs hosts; then
        printInfoMsg "No active SSH port forwards started by this script were found."
        return
    fi

    local header; header=$(printf "%-10s %-8s %-30s %s" "PID" "TYPE" "FORWARD" "HOST")
    printMsg "  ${C_WHITE}${header}${T_RESET}"

    for i in "${!pids[@]}"; do
        printMsg "  $(_format_port_forward_line "${pids[i]}" "${types[i]}" "${specs[i]}" "${hosts[i]}")${T_RESET}"
    done

    # empty line for spacing
    printMsg ""
}

# Lists all configured SSH hosts with details.
list_all_hosts() {
    printBanner "List All Configured Hosts"

    local -a menu_options
    # Get detailed host list, including key info.
    get_detailed_ssh_hosts_menu_options menu_options "true"

    if [[ ${#menu_options[@]} -eq 0 ]]; then
        printInfoMsg "No hosts found in your SSH config file."
        return
    fi

    local header
    header=$(printf "%-20s %s" "HOST ALIAS" "user@hostname[:port] (key)")
    printMsg "${C_WHITE}${header}${T_RESET}"
    printMsg "${C_GRAY}${DIV}${T_RESET}"

    for option in "${menu_options[@]}"; do
        # The menu options are already formatted with colors.
        printMsg "${option}${T_RESET}"
    done

    # add space
    printMsg ""
}

# --- Port Forwarding View Helpers ---

# (Private) Formats a line for displaying a saved port forward.
# Usage: _format_saved_port_forward_line <status> <pid> <type> <spec> <host> <desc>
_format_saved_port_forward_line() {
    local status="$1" pid="$2" type="$3" spec="$4" host="$5" desc="$6"; local type_color=""
    if [[ "$type" == "Local" ]]; then type_color="$C_L_BLUE"; elif [[ "$type" == "Remote" ]]; then type_color="$C_L_YELLOW"; fi
    local status_icon; if [[ "$status" == "active" ]]; then status_icon="${C_L_GREEN}[✓]"; else status_icon="${C_GRAY}[-]"; fi

    local line1; line1=$(printf "${C_L_CYAN}%-20s${C_L_WHITE} %-45s" "$host" "$spec")

    # The second line is indented to appear nested under the first.
    local line2; line2=$(printf "   %-3s %-8s${type_color} %-7s${C_L_WHITE} %-45s" \
        "$status_icon" "${pid:-off}" "$type" "$desc")

    printf "%s\n%s${T_RESET}" "$line1" "$line2"
}

_port_forward_view_draw_header() {
    local header1 header2
    header1=$(printf "   %-20s %-45s" "HOST" "FORWARD")
    # The second header line is indented to match the item's second line.
    header2=$(printf "   %-3s %-8s %-7s %-45s" "[ ]" "PID" "TYPE" "DESCRIPTION")
    printMsg "${C_WHITE}${header1}${T_RESET}"
    printMsg "${C_WHITE}${header2}${T_RESET}"
}

_port_forward_view_draw_footer() {
    printMsg "  ${T_BOLD}Navigation:${T_RESET}   ${C_L_CYAN}↓/↑/j/k${T_RESET} Move | ${C_L_YELLOW}Q/ESC${T_RESET} Back"
    printMsg "  ${T_BOLD}Actions:${T_RESET}      ${C_L_GREEN}(A)dd${T_RESET} | ${C_L_RED}(D)elete${T_RESET} | ${C_L_CYAN}(E)dit${T_RESET} | ${C_L_BLUE}(C)lone${T_RESET} | ${C_L_GREEN}ENTER${T_RESET} Start/Stop"
}

_port_forward_view_refresh() {
    local -n out_menu_options="$1" out_data_payloads="$2"; out_menu_options=(); out_data_payloads=()
    local -a saved_types saved_specs saved_hosts saved_descs; _get_saved_port_forwards saved_types saved_specs saved_hosts saved_descs
    local -a active_pids active_types active_specs active_hosts; _get_active_port_forwards active_pids active_types active_specs active_hosts
    local -A active_map
    for i in "${!active_pids[@]}"; do
        local key="${active_types[i]}|${active_specs[i]}|${active_hosts[i]}"; active_map["$key"]="${active_pids[i]}"
    done
    for i in "${!saved_types[@]}"; do
        local type="${saved_types[i]}" spec="${saved_specs[i]}" host="${saved_hosts[i]}" desc="${saved_descs[i]}"
        local key="${type}|${spec}|${host}"
        local status status_pid
        if [[ -n "${active_map[$key]}" ]]; then status="active"; status_pid="${active_map[$key]}"; else status="inactive"; status_pid=""; fi
        out_menu_options+=("$(_format_saved_port_forward_line "$status" "$status_pid" "$type" "$spec" "$host" "$desc")")
        out_data_payloads+=("$i|$type|$spec|$host|$desc|$status_pid")
    done
}

_port_forward_view_key_handler() {
    local key="$1"
    local selected_payload="$2"
    # local selected_index="$3" # Unused before move
    local -n current_option_ref="$4"
    local num_options="$5"
    local -n out_result="$6"

    out_result="noop"
    local idx type spec host desc pid
    if [[ -n "$selected_payload" ]]; then IFS='|' read -r idx type spec host desc pid <<< "$selected_payload"; fi
    case "$key" in
        "$KEY_UP"|"k")
            if (( num_options > 0 )); then current_option_ref=$(( (current_option_ref - 1 + num_options) % num_options )); fi
            ;;
        "$KEY_DOWN"|"j")
            if (( num_options > 0 )); then current_option_ref=$(( (current_option_ref + 1) % num_options )); fi
            ;;
        'a'|'A') run_menu_action "add_saved_port_forward"; out_result="refresh" ;;
        'e'|'E') if [[ -n "$selected_payload" ]]; then run_menu_action "edit_saved_port_forward" "$idx"; out_result="refresh"; fi ;;
        'd'|'D')
            if [[ -n "$selected_payload" ]]; then
                # Move cursor down past the list and its top divider.
                printf '\n' >/dev/tty
                # The area to clear is the 2 lines of footer text + 1 bottom divider line.
                local lines_to_clear=3
                clear_lines_down "$lines_to_clear" >/dev/tty

                # Show the prompt in the cleared footer area.
                printBanner "${C_RED}Delete / Remove Port Forward${T_RESET}"
                if prompt_yes_no "Permanently ${C_RED}delete${T_RESET} saved forward\n     '${spec}' on '${host}'?" "n"; then
                    local -a all_types all_specs all_hosts all_descs; _get_saved_port_forwards all_types all_specs all_hosts all_descs
                    local -a new_types new_specs new_hosts new_descs
                    for i in "${!all_types[@]}"; do
                        if [[ "$i" -ne "$idx" ]]; then new_types+=("${all_types[i]}"); new_specs+=("${all_specs[i]}"); new_hosts+=("${all_hosts[i]}"); new_descs+=("${all_descs[i]}"); fi
                    done
                    _save_all_port_forwards new_types new_specs new_hosts new_descs
                    printOkMsg "Deleted saved port forward."; sleep 1
                fi
                out_result="refresh"
            fi ;;
        'c'|'C') if [[ -n "$selected_payload" ]]; then run_menu_action "clone_saved_port_forward" "$type" "$spec" "$host" "$desc"; out_result="refresh"; fi ;;
        "$KEY_ENTER")
            if [[ -n "$selected_payload" ]]; then
                if [[ -n "$pid" ]]; then run_menu_action "deactivate_port_forward" "$pid" "$spec" "$host"; else run_menu_action "activate_port_forward" "$type" "$spec" "$host"; fi
                out_result="refresh"
            fi ;;
        "$KEY_ESC"|"q"|"Q") out_result="exit" ;; # Exit view
    esac
}

interactive_port_forward_view() {
    _interactive_list_view \
        "Saved ${C_L_CYAN}Port Forwards${C_BLUE}" \
        "_port_forward_view_draw_header" \
        "_port_forward_view_refresh" \
        "_port_forward_view_key_handler" \
        "_port_forward_view_draw_footer"
}

# (Private) A wrapper for running a menu action.
# It clears the screen, runs the function, and then prompts to continue.
run_menu_action() {
    local action_func="$1"
    shift
    clear

    # Show the cursor. Many actions launched from cursor-less views (like the
    # server list) require user input and thus need a visible cursor.
    printMsgNoNewline "${T_CURSOR_SHOW}" >/dev/tty

    # Call the function with any remaining arguments. It's expected to print its own banner.
    "$action_func" "$@"

    # Hide the cursor again before returning to the parent view, which expects
    # the cursor to be hidden. This is done before prompt_to_continue, which
    # does not require a visible cursor.
    printMsgNoNewline "${T_CURSOR_HIDE}" >/dev/tty

    # After the action is complete, wait for user input before returning to the menu.
    prompt_to_continue
}

# (Private) Generic function to display and handle a submenu loop.
# It takes a banner title, an array of ordered options, and a map of options to actions.
# Usage: _run_submenu <banner_title> "Option 1" "action1" "Option 2" "action2" ...
_run_submenu() {
    local banner_title="$1"
    shift
    local -a menu_definition=("$@")

    local -a ordered_options
    local -A actions_map

    for ((i=0; i<${#menu_definition[@]}; i+=2)); do
        ordered_options+=("${menu_definition[i]}")
        actions_map["${menu_definition[i]}"]="${menu_definition[i+1]}"
    done

    # Add the 'Back' option to the list for display
    local -a menu_options=("${ordered_options[@]}" "Back to main menu")

    while true; do
        clear
        printBanner "$banner_title"

        local selected_index
        selected_index=$(interactive_single_select_menu "Select an action:" "" "${menu_options[@]}")
        [[ $? -ne 0 ]] && break # ESC/q from menu returns to the previous menu

        local selected_option="${menu_options[$selected_index]}"

        if [[ "$selected_option" == "Back to main menu" ]]; then
            break
        fi

        # Get the action from the map.
        local action="${actions_map[$selected_option]}"

        # Handle special actions identified by a "SPECIAL_" prefix.
        if [[ "$action" == "SPECIAL_CONNECT" ]]; then
            clear
            printBanner "Connect to a server"
            local selected_host
            selected_host=$(select_ssh_host "Select a host to connect to:")
            if [[ $? -eq 0 ]]; then
                # Replace the script process with the ssh client.
                exec ssh "$selected_host"
            fi
            # If connection is cancelled, the loop continues.
        elif [[ "$action" == "SPECIAL_EDIT_CONFIG" ]]; then
            local editor="${EDITOR:-nvim}"
            if ! command -v "${editor}" &>/dev/null; then
                printErrMsg "Editor '${editor}' not found. Please set the EDITOR environment variable."
                prompt_to_continue
            else
                "${editor}" "${SSH_CONFIG_PATH}"
            fi
        else
            # This is the standard case: a function name to be passed to run_menu_action.
            if [[ -n "$action" ]]; then
                run_menu_action "$action"
            else
                printErrMsg "Internal error: No action defined for '${selected_option}'."
                prompt_to_continue
            fi
        fi
    done
}

# --- Server Management View Helpers ---

_server_view_draw_header() {
    local header; header=$(printf "   %-20s ${C_WHITE}%s${T_RESET}" "HOST ALIAS" "user@hostname[:port] (key)")
    printMsg "${C_WHITE}${header}${T_RESET}"
}

_server_view_draw_footer() {
    printMsg "  ${T_BOLD}Navigation:${T_RESET}   ${C_L_CYAN}↓/↑/j/k${T_RESET} Move | ${C_L_YELLOW}Q/ESC${T_RESET} Back"
    printMsg "  ${T_BOLD}Host Actions:${T_RESET} ${C_L_GREEN}(A)dd${T_RESET} | ${C_L_RED}(D)elete${T_RESET} | ${C_L_BLUE}(C)lone${T_RESET}"
    printMsg "  ${T_BOLD}Host Edit:${T_RESET}    ${C_L_CYAN}(E)dit${T_RESET} host details"
    printMsg "  ${T_BOLD}Connection:${T_RESET}   ${C_L_YELLOW}ENTER${T_RESET} Connect | (${C_L_CYAN}t${T_RESET})est selected | (${C_L_CYAN}T${T_RESET})est all"
}

_server_view_refresh() {
    local -n out_menu_options="$1"
    local -n out_data_payloads="$2"
    # Get raw host names for the data payload
    mapfile -t out_data_payloads < <(get_ssh_hosts)
    # Get formatted strings for display
    get_detailed_ssh_hosts_menu_options out_menu_options "true"
}

_server_view_key_handler() {
    local key="$1"
    local selected_host="$2"
    # local selected_index="$3" # Unused before move
    local -n current_option_ref="$4"
    local num_options="$5"
    local -n out_result="$6"

    out_result="noop"
    case "$key" in
        "$KEY_UP"|"k")
            if (( num_options > 0 )); then current_option_ref=$(( (current_option_ref - 1 + num_options) % num_options )); fi
            ;;
        "$KEY_DOWN"|"j")
            if (( num_options > 0 )); then current_option_ref=$(( (current_option_ref + 1) % num_options )); fi
            ;;
        "$KEY_ENTER")
            if [[ -n "$selected_host" ]]; then
                # The cursor is at the end of the list content.
                # Move down one line to be past the top divider.
                printf '\n' >/dev/tty

                # The area to clear is the 4 lines of footer text + 1 bottom divider line.
                local lines_to_clear=5
                clear_lines_down "$lines_to_clear" >/dev/tty

                # The cursor is now at the start of where the footer text was.
                # Show the prompt here.
                if prompt_yes_no "Connect to '${selected_host}'?" "y"; then
                    clear; exec ssh "$selected_host"
                else
                    # User cancelled. The prompt prints a cancellation message.
                    # Trigger a full redraw to restore the footer and clean up.
                    out_result="refresh"
                fi
            fi
            ;;
        'a'|'A')
            # Move cursor down past the list and its top divider.
            printf '\n' >/dev/tty
            # The area to clear is the 4 lines of footer text + 1 bottom divider line.
            local lines_to_clear=5
            clear_lines_down "$lines_to_clear" >/dev/tty

            # Show the prompt in the cleared footer area.
            printBanner "${C_GREEN}Add New SSH Host${T_RESET}"
            local -a add_options=("Create a new host from scratch" "Clone settings from an existing host")
            local add_choice_idx
            add_choice_idx=$(interactive_single_select_menu "How would you like to add the new host?" "" "${add_options[@]}")

            if [[ $? -eq 0 ]]; then
                if [[ "${add_options[$add_choice_idx]}" == "Clone settings from an existing host" ]]; then
                    run_menu_action "clone_ssh_host"
                else
                    run_menu_action "add_ssh_host_from_scratch"
                fi
            fi
            out_result="refresh"
            ;;
        'e'|'E') if [[ -n "$selected_host" ]]; then run_menu_action "edit_ssh_host" "$selected_host"; out_result="refresh"; fi ;;
        'd'|'D')
            if [[ -n "$selected_host" ]]; then
                # Move cursor down past the list and its top divider.
                printf '\n' >/dev/tty
                # The area to clear is the 4 lines of footer text + 1 bottom divider line.
                local lines_to_clear=5
                clear_lines_down "$lines_to_clear" >/dev/tty

                # Show the prompt in the cleared footer area.
                printBanner "${C_RED}Delete / Remove Host${T_RESET}"
                if prompt_yes_no "Are you sure you want to ${C_RED}remove${T_RESET} '${selected_host}'?\n    This will permanently delete the host from your config." "n"; then
                    # User confirmed deletion.
                    # Get the IdentityFile path *before* removing the host from the config.
                    local identity_file_to_check
                    identity_file_to_check=$(_get_explicit_ssh_config_value "$selected_host" "IdentityFile")

                    # Get the config content without the specified host block
                    local new_config_content
                    new_config_content=$(_remove_host_block_from_config "$selected_host")

                    # Overwrite the config file with the new content, squeezing blank lines
                    echo "$new_config_content" | cat -s > "$SSH_CONFIG_PATH"
                    printOkMsg "Host '${selected_host}' has been removed."

                    # Now, handle the potentially orphaned key in the same interactive space.
                    _cleanup_orphaned_key "$identity_file_to_check"
                    sleep 1 # Give user a moment to see the result.
                fi
                # Whether confirmed or cancelled, trigger a full redraw to restore the UI.
                # The prompt_yes_no function prints a cancellation message if needed.
                out_result="refresh"
            fi
            ;;
        'c'|'C') if [[ -n "$selected_host" ]]; then run_menu_action "clone_ssh_host" "$selected_host"; out_result="refresh"; fi ;;
        't')
            if [[ -n "$selected_host" ]]; then
                clear; printBanner "Test SSH Connection"; _test_connection_for_host "$selected_host"; prompt_to_continue
                out_result="refresh" # Trigger a full redraw to restore the view.
            fi
            ;;
        'T')
            run_menu_action "test_all_ssh_connections"
            out_result="refresh" # Trigger a full redraw to restore the view.
            ;;
        "$KEY_ESC"|"q"|"Q") out_result="exit" ;; # Exit view
    esac
}

interactive_server_management_view() {
    _interactive_list_view \
        "${C_L_CYAN}Server/Host${C_BLUE} Management" \
        "_server_view_draw_header" \
        "_server_view_refresh" \
        "_server_view_key_handler" \
        "_server_view_draw_footer"
}

# --- Key Management View Helpers ---

_key_view_draw_header() {
    local header; header=$(printf " %-25s %-10s %-6s %s" "KEY FILENAME" "TYPE" "BITS" "COMMENT")
    printMsg "  ${C_WHITE}${header}${T_RESET}"
}

_key_view_draw_footer() {
    printMsg "  ${T_BOLD}Navigation:${T_RESET}   ${C_L_CYAN}↓/↑/j/k${T_RESET} Move | ${C_L_YELLOW}Q/ESC${T_RESET} Back"
    printMsg "  ${T_BOLD}Key Actions:${T_RESET}  ${C_L_GREEN}(A)dd${T_RESET} Key | ${C_L_RED}(D)elete${T_RESET} | ${C_L_CYAN}(R)ename${T_RESET}"
    printMsg "                (${C_L_CYAN}V${T_RESET})iew public | (${C_L_BLUE}C${T_RESET})opy to Server | Re-gen (${C_L_CYAN}P${T_RESET})ublic"
}

# (Private) Verifies a file is a valid private key and extracts its details.
_get_key_details() {
    local key_file="$1"
    local details
    # Heuristic: A file whose first line looks like a public key is not a private key.
    if head -n 1 "$key_file" 2>/dev/null | grep -q -E '^(ssh-(rsa|dss|ed25519)|ecdsa-sha2-nistp(256|384|521)) '; then return 1; fi
    # Attempt to get the key fingerprint. If this fails, it's not a valid key file.
    details=$(ssh-keygen -l -f "$key_file" 2>/dev/null)
    if [[ -z "$details" || $(echo "$details" | wc -l) -ne 1 ]]; then return 1; fi
    local bits; bits=$(echo "$details" | awk '{print $1}')
    local type; type=$(echo "$details" | awk '{print $NF}' | tr -d '()')
    local comment; comment=$(echo "$details" | awk '{for(i=3;i<NF;i++) printf "%s ",$i}' | sed 's/ $//')
    comment="${comment% }" # Use parameter expansion to trim trailing space
    [[ -z "$comment" ]] && comment="(no comment)"
    echo "$type $bits $comment"
}

_key_view_refresh() {
    local -n out_menu_options="$1"
    local -n out_data_payloads="$2"
    out_data_payloads=()
    out_menu_options=()
    # Find all files in SSH_DIR that do NOT end in .pub, then verify they are valid private keys.
    while IFS= read -r key_path; do
        local details_str
        if details_str=$(_get_key_details "$key_path"); then
            out_data_payloads+=("$key_path")
            local filename; filename=$(basename "$key_path")
            local key_type key_bits key_comment
            read -r key_type key_bits key_comment <<< "$details_str"
            local formatted_string
            # formatted_string=$(printf "${C_MAGENTA}%-25s${T_RESET} ${C_YELLOW}%-10s${T_RESET} %-6s %-23s" "${filename}" "${key_type}" "${key_bits}" "${key_comment}")
            formatted_string=$(printf "${C_MAGENTA}%-25s ${C_YELLOW}%-10s ${C_WHITE}%-6s %-23s" "${filename}" "${key_type}" "${key_bits}" "${key_comment}")
            out_menu_options+=("$formatted_string")
        fi
    done < <(find "$SSH_DIR" -maxdepth 1 -type f ! -name "*.pub")
}

_key_view_key_handler() {
    local key="$1"
    local selected_key_path="$2"
    # local selected_index="$3" # Unused before move
    local -n current_option_ref="$4"
    local num_options="$5"
    local -n out_result="$6"

    out_result="noop"
    case "$key" in
        "$KEY_UP"|"k")
            if (( num_options > 0 )); then current_option_ref=$(( (current_option_ref - 1 + num_options) % num_options )); fi
            ;;
        "$KEY_DOWN"|"j")
            if (( num_options > 0 )); then current_option_ref=$(( (current_option_ref + 1) % num_options )); fi
            ;;
        'a'|'A')
            # Move cursor down past the list and its bottom divider.
            printf '\n' >/dev/tty

            # Footer is 3 lines + 1 bottom divider line.
            local lines_to_clear=4
            clear_lines_down "$lines_to_clear" >/dev/tty

            # Show the prompt in the cleared footer area.
            printBanner "${C_GREEN}Add New SSH Key${T_RESET}"
            local -a key_types=("ed25519 (recommended)" "rsa (legacy, 4096 bits)")
            local selected_index
            selected_index=$(interactive_single_select_menu "Select the type of key to generate:" "" "${key_types[@]}")

            if [[ $? -eq 0 ]]; then
                # A selection was made. Now clear the screen and run the rest of the wizard.
                run_menu_action "_generate_ssh_key_from_type_with_banner" "${key_types[$selected_index]}"
            fi
            out_result="refresh" ;;
        'c'|'C')
            if [[ -n "$selected_key_path" ]]; then
                if [[ -f "${selected_key_path}.pub" ]]; then
                    run_menu_action "copy_selected_ssh_key" "${selected_key_path}.pub"
                else
                    # This path doesn't use run_menu_action, so we handle the UI manually.
                    clear; printErrMsg "Public key for '${selected_key_path/#$HOME/\~}' not found."; prompt_to_continue
                fi
                # In either case, the screen was cleared, so a full refresh is needed.
                out_result="refresh"
            fi ;;
        'd'|'D')
            if [[ -n "$selected_key_path" ]]; then
                # Move cursor down past the list and its bottom divider.
                printf '\n' >/dev/tty

                # Footer is 3 lines + 1 bottom divider line.
                local lines_to_clear=4
                clear_lines_down "$lines_to_clear" >/dev/tty

                # Build the multi-line question for the prompt.
                local pub_key_path="${selected_key_path}.pub"
                printBanner "${C_RED}Delete Key${T_RESET}"
                local question="Are you sure you want to permanently delete this key pair?\n     Private: ${selected_key_path/#$HOME/\~}"
                if [[ -f "$pub_key_path" ]]; then question+="\n     Public:  ${pub_key_path/#$HOME/\~}"; fi

                # Show the prompt in the cleared footer area.
                if prompt_yes_no "$question" "n"; then
                    # User confirmed. Run the deletion with a spinner.
                    # The spinner will print its own success/error message.
                    run_with_spinner "Deleting key pair..." rm -f "$selected_key_path" "${selected_key_path}.pub"
                    # Wait a moment for the user to see the result before redrawing.
                    sleep 1
                fi
                # Whether confirmed or cancelled, trigger a full refresh to restore the UI.
                # The prompt_yes_no function prints a cancellation message if needed.
                out_result="refresh"
            fi ;;
        'r'|'R')
            if [[ -n "$selected_key_path" ]]; then run_menu_action "rename_ssh_key" "$selected_key_path"; out_result="refresh"; fi ;;
        'v'|'V')
            if [[ -n "$selected_key_path" ]]; then
                if [[ -f "${selected_key_path}.pub" ]]; then
                    run_menu_action "view_public_key" "${selected_key_path}.pub"
                else
                    clear; printErrMsg "Public key for '${selected_key_path/#$HOME/\~}' not found."; prompt_to_continue
                fi
                out_result="refresh"
            fi ;;
        'p'|'P')
            if [[ -n "$selected_key_path" ]]; then run_menu_action "regenerate_public_key" "$selected_key_path"; out_result="refresh"; fi ;;
        "$KEY_ESC"|"q"|"Q")
            out_result="exit" ;; # Exit view
    esac
}

interactive_key_management_view() {
    _interactive_list_view \
        "${C_MAGENTA}Key${C_BLUE} Management" \
        "_key_view_draw_header" \
        "_key_view_refresh" \
        "_key_view_key_handler" \
        "_key_view_draw_footer"
}

# Bypasses the main menu and goes directly to the host selection for a direct connection.
direct_connect() {
    local selected_host
    selected_host=$(select_ssh_host "Select a host to connect to:")
    if [[ $? -eq 0 ]]; then
        # Replace the script process with the ssh client.
        exec ssh "$selected_host"
    fi
    # If selection is cancelled, the script will just exit.
    # select_ssh_host prints a cancellation message, so we exit with a non-zero status
    # to indicate the requested action was not completed.
    exit 1
}

# Bypasses the main menu and goes directly to testing connections.
# Handles interactive selection, a specific host, or all hosts.
direct_test() {
    local target="$1"

    if [[ -z "$target" ]]; then
        # No target specified, run interactive selection.
        # This function already has a banner, so we just call it.
        test_ssh_connection
        return
    fi

    if [[ "$target" == "all" ]]; then
        # Target is 'all', test all connections.
        test_all_ssh_connections
        return
    fi

    # Target is a specific host. First, validate it exists.
    # Use grep with -F (fixed string) and -x (exact line match) for robust validation.
    if get_ssh_hosts | grep -qFx "$target"; then
        printBanner "Test SSH Connection"
        _test_connection_for_host "$target"
    else
        printErrMsg "Host '${target}' not found in your SSH config."
        return 1
    fi
}

# (Private) Ensures prerequisites are met and SSH directory/config are set up.
# Usage: _setup_environment "cmd1" "cmd2" ...
_setup_environment() {
    prereq_checks "$@"
    mkdir -p "$SSH_DIR"; chmod 700 "$SSH_DIR"
    touch "$SSH_CONFIG_PATH"; chmod 600 "$SSH_CONFIG_PATH"
    touch "$PORT_FORWARDS_CONFIG_PATH"; chmod 600 "$PORT_FORWARDS_CONFIG_PATH"
}

# --- Main Menu View Helpers ---

_main_menu_view_draw_header() {
    printMsg "${T_QST_ICON} What would you like to do?"
}

_main_menu_view_draw_footer() {
    printMsg "  ${T_BOLD}Navigation:${T_RESET}   ${C_L_CYAN}↓/↑/j/k${T_RESET} Move | ${C_L_YELLOW}Q/ESC${T_RESET} Quit"
    printMsg "  ${T_BOLD}Shortcuts:${T_RESET}    ${C_L_CYAN}(S)ervers${T_RESET} | ${C_MAGENTA}(K)eys${T_RESET} | ${C_L_CYAN}(P)ort${T_RESET} Forwards"
    printMsg "                ${C_L_BLUE}(E)dit${T_RESET} ssh file | ${C_YELLOW}(Q)uit${T_RESET}"
}

_main_menu_view_refresh() {
    local -n out_menu_options="$1"
    local -n out_data_payloads="$2"

    local -a items=(
        "${C_L_CYAN}(S)erver${T_RESET} Management"
        "${C_L_MAGENTA}(K)ey${T_RESET} Management"
        "${C_L_CYAN}(P)ort${T_RESET} Forwarding"
        "${C_L_BLUE}(E)dit${T_RESET} SSH config in editor"
        "${C_YELLOW}(Q)uit${T_RESET}"
    )

    # Find the maximum visible length and store stripped items
    local max_len=0
    local -a stripped_items=()
    for item in "${items[@]}"; do
        # Strip ANSI escape codes to calculate the real display length
        local stripped_item; stripped_item=$(strip_ansi_codes "$item")
        stripped_items+=("$stripped_item")
        if (( ${#stripped_item} > max_len )); then
            max_len=$(( ${#stripped_item} + 1 ))
        fi
    done

    # Build the final menu options array, padding each item to the max length
    out_menu_options=()
    for i in "${!items[@]}"; do
        local padding_len=$(( max_len - ${#stripped_items[i]} ))
        local padded_item
        printf -v padded_item "%s%*s" "${items[i]}" "$padding_len" ""
        out_menu_options+=("$padded_item")
    done

    # The data payloads are the actions themselves.
    out_data_payloads=(
        "server"
        "key"
        "port"
        "edit"
        "exit"
    )
}

_perform_main_menu_action() {
    local action="$1"
    local -n out_result_ref="$2"

    case "$action" in
        "server") interactive_server_management_view ;;
        "key") interactive_key_management_view ;;
        "port") interactive_port_forward_view ;;
        "edit")
            clear
            local editor="${EDITOR:-nvim}"
            if ! command -v "${editor}" &>/dev/null; then
                printBanner "Error"
                printErrMsg "Editor '${editor}' not found. Please set the EDITOR environment variable."
                prompt_to_continue
            else
                printMsgNoNewline "${T_CURSOR_SHOW}" >/dev/tty
                "${editor}" "${SSH_CONFIG_PATH}"
                printMsgNoNewline "${T_CURSOR_HIDE}" >/dev/tty
            fi
            ;;
        "exit") out_result_ref="exit" ;;
    esac

    if [[ "$out_result_ref" != "exit" ]]; then
        out_result_ref="refresh"
    fi
}

_main_menu_view_key_handler() {
    local key="$1"
    local selected_action="$2"
    # local selected_index="$3" # Unused
    local -n current_option_ref="$4"
    local num_options="$5"
    local -n out_result="$6"

    out_result="noop" # Default to redraw

    case "$key" in
        "$KEY_UP"|"k")
            if (( num_options > 0 )); then current_option_ref=$(( (current_option_ref - 1 + num_options) % num_options )); fi
            ;;
        "$KEY_DOWN"|"j")
            if (( num_options > 0 )); then current_option_ref=$(( (current_option_ref + 1) % num_options )); fi
            ;;
        "$KEY_ENTER")
            if [[ -n "$selected_action" ]]; then _perform_main_menu_action "$selected_action" out_result; fi
            ;;
        's'|'S') _perform_main_menu_action "server" out_result ;;
        'K') _perform_main_menu_action "key" out_result ;;
        'p'|'P') _perform_main_menu_action "port" out_result ;;
        'e'|'E') _perform_main_menu_action "edit" out_result ;;
        'x'|'X') _perform_main_menu_action "exit" out_result ;;
        "$KEY_ESC"|"q"|"Q") out_result="exit" ;;
    esac
}

interactive_main_menu_view() {
    _interactive_list_view \
        "SSH Manager" \
        "_main_menu_view_draw_header" \
        "_main_menu_view_refresh" \
        "_main_menu_view_key_handler" \
        "_main_menu_view_draw_footer"
}

# Main application loop.
main_loop() {
    interactive_main_menu_view
    clear
    printOkMsg "Goodbye!"
}

main() {
    # Handle flags first
    if [[ $# -gt 0 ]]; then
        case "$1" in
            -h|--help)
                print_usage
                exit 0
                ;;
            -a|--add)
                # Prereqs for add mode
                _setup_environment "ssh" "ssh-keygen" "ssh-copy-id" "awk" "grep"
                # The add_ssh_host function is fully interactive and self-contained.
                add_ssh_host
                exit 0
                ;;
            -p|--port-forward)
                # Prereqs for port forwarding. ps and kill are for managing forwards.
                _setup_environment "ssh" "awk" "grep" "ps" "kill"
                # The view is self-contained and has its own loop.
                interactive_port_forward_view
                exit 0
                ;;
            -l|--list-hosts)
                # Prereqs for listing hosts.
                _setup_environment "ssh" "awk" "grep"
                list_all_hosts
                exit 0
                ;;
            -f|--list-forwards)
                # Prereqs for listing port forwards.
                _setup_environment "ps" "grep"
                list_active_port_forwards
                exit 0
                ;;
            -c|--connect | -t|--test)
                # Prereqs for connect and test modes are the same
                _setup_environment "ssh" "awk" "grep"
                if [[ "$1" == "-c" || "$1" == "--connect" ]]; then
                    direct_connect
                    # direct_connect either execs or exits, so we shouldn't get here.
                    exit 1
                else
                    # The second argument ($2) is the target for the test.
                    direct_test "$2"
                    exit $?
                fi
                ;;
            *)
                print_usage
                echo
                printErrMsg "Unknown option: $1"
                exit 1
                ;;
        esac
    fi

    # Default interactive mode (no flags)
    _setup_environment "ssh" "ssh-keygen" "ssh-copy-id" "awk" "cat" "grep" "rm" "mktemp" "cp" "date"

    main_loop
}

# This block will only run when the script is executed directly, not when sourced.
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    main "$@"
fi